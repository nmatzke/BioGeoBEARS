12*0.2
2.4/12
library(devtools)#
devtools::install_github(repo="nmatzke/BioGeoBEARS", INSTALL_opts="--byte-compile")
...x/08zx5k8n735gwg9v796004l40000gr/T/Rtmp6C1p8d/remotes35a718a40020/nmatzke-BioGeoBEARS-ba6f260/DESCRIPTION’ ...#
   Warning in utils::tar(filepath, pkgname, compression = compression, compression_level = 9L,  :#
     storing paths of more than 100 bytes is not portable:#
     ‘BioGeoBEARS/inst/extdata/examples/395lab/conifer_DEC_traits_models/geological_distances_v3_div100_stay_same.txt’#
   Warning in utils::tar(filepath, pkgname, compression = compression, compression_level = 9L,  :#
     storing paths of more than 100 bytes is not portable:#
     ‘BioGeoBEARS/inst/extdata/examples/Psychotria_M3strat/BSM_to_simmap/50BSMs_in_phytools_simmap_format.pdf’#
   Warning in utils::tar(filepath, pkgname, compression = compression, compression_level = 9L,  :#
     storing paths of more than 100 bytes is not portable:#
     ‘BioGeoBEARS/inst/extdata/examples/Psychotria_M4b_dists_stratified/Hawaii_KOMH_dispersal_multipliers.txt’#
   Warning in utils::tar(filepath, pkgname, compression = compression, compression_level = 9L,  :#
Installing package into ‘/Users/nmat471/Library/R/arm64/4.5/library’#
(as ‘lib’ is unspecified)
library(BioGeoBEARS)
library(BioGeoBEARS)#
	sourceall("/GitHub/str2phy/Rsrc/")
library(BioGeoBEARS)#
	sourceall("~/GitHub/str2phy/Rsrc/")
install.packages("queryup")#
#
library(devtools)#
devtools::install_github(repo="nmatzke/BioGeoBEARS")#
#
if (!require("BiocManager", quietly = TRUE))#
    install.packages("BiocManager")#
#
BiocManager::install("msa")#
BiocManager::install("ginmappeR")
library(BioGeoBEARS)#
	sourceall("/GitHub/str2phy/Rsrc/")
library(BioGeoBEARS)#
	sourceall("~/GitHub/str2phy/Rsrc/")#
	fn = "~/GitHub/str2phy/substmat/try_mafft_custom3DI/usalign_test3.fasta"
seqs = ape::read.FASTA(fn)#
	tipnames = names(seqs)#
	split="_"
split="_"#
	tipnames#
	names_w_justgids(tipnames, split=split)
fixnames(tipnames)
seqids = c("AAC07752","AAC73831","AAC74960","AAC76042","AAG03587")#
tmpfn = "tmpseqs.fasta"#
db = "protein"#
type = "AA"#
more_than_500seqs = FALSE#
tmpseqs = get_fasta_seqs_from_seqids(seqids, tmpfn, db, type, more_than_500seqs)
install.packages("reutils")
BiocManager::install("reutils")
library(reutils)
seqlabels = get_seq_labels_by_FASTA_download(seqids, outfn="tmpseqs.fasta", runslow=TRUE, chunksize=250, wait_time=1)
library(seqinr)
install.packages("seqinr")
seqids = c("AAC07752","AAC73831","AAC74960","AAC76042","AAG03587")#
tmpfn = "tmpseqs.fasta"#
db = "protein"#
type = "AA"#
more_than_500seqs = FALSE
tmpseqs = get_fasta_seqs_from_seqids(seqids, tmpfn, db, type, more_than_500seqs)
library(BioGeoBEARS)#
library(seqinr)#
library(reutils)#
sourceall("~/GitHub/str2phy/Rsrc/")
seqlabels = get_seq_labels_by_FASTA_download(seqids, outfn="tmpseqs.fasta", runslow=TRUE, chunksize=250, wait_time=1)
seqids = c("AAC07752","AAC73831","AAC74960","AAC76042","AAG03587")#
tmpfn = "tmpseqs.fasta"#
db = "protein"#
type = "AA"#
more_than_500seqs = FALSE#
tmpseqs = get_fasta_seqs_from_seqids(seqids, tmpfn, db, type, more_than_500seqs)
tmpseqs
install.packages()
library(raster)#
library(sf)#
library(ggplot2)#
library(geodata)#
library(terra)#
library(spatstat)#
library(pROC) # Calculates ROC for GLM#
library(MASS)#
library(randomForest) # Random forest package
species_name <- "Amblyomma americanum "#
gbif_data <- occ_search(scientificName = species_name, limit = 200, hasCoordinate = TRUE)#
occs <- gbif_data$data[, c("decimalLongitude", "decimalLatitude")]#
head(occs)
library(rgbif)#
library(dismo) # SDM package#
library(rJava) # Java for MaxEnt. #
# If this doesn't install properly, download the proper #
# Java Development Kit for your OS and bit version #
# here: https://www.oracle.com/java/technologies/downloads/?er=221886#
library(raster)#
library(sf)#
library(ggplot2)#
library(geodata)#
library(terra)#
library(spatstat)#
library(pROC) # Calculates ROC for GLM#
library(MASS)#
library(randomForest) # Random forest package
occ_search
species_name <- "Amblyomma americanum "#
gbif_data <- rgbif::occ_search(scientificName = species_name, limit = 200, hasCoordinate = TRUE)
occs_sp <- SpatialPointsDataFrame(coords = occs, data = data.frame(occs), proj4string = CRS("+proj=longlat +datum=WGS84"))
gbif_data
occs <- gbif_data$data[, c("decimalLongitude", "decimalLatitude")]
head(occs)
occs_sp <- SpatialPointsDataFrame(coords = occs, data = data.frame(occs), proj4string = CRS("+proj=longlat +datum=WGS84"))
SpatialPointsDataFrame
occs_sp <- sp::SpatialPointsDataFrame(coords = occs, data = data.frame(occs), proj4string = CRS("+proj=longlat +datum=WGS84"))
tempdir()
bioclim_data <- worldclim_global(var="bio", res=2.5, path=tempdir())#
na_extent <- ext(-130, -60, 20, 55)  # North America extent#
bioclim_na <- crop(bioclim_data, na_extent)
set.seed(4594) # Set seed for random points for reproducibility#
background_points <- randomPoints(clim, 200)#
plot(bioclim_na[[1]], main = "BIO1 - Annual Mean Temp (C)") #
points(background_points, pch = 21)
randomPoints
set.seed(4594) # Set seed for random points for reproducibility#
background_points <- dismo::randomPoints(bioclim_na, 200)#
background_points
set.seed(4594) # Set seed for random points for reproducibility#
background_points <- dismo::randomPoints(na_extent, 200)#
background_points
?randomPoints
bioclim_na
clim <- raster::stack(bioclim_na) #
#
# Plot WorldClim's Bio1: Annual Mean Temperature#
plot(bioclim_na[[1]], main = "BIO1 - Annual Mean Temp (C)") #
plot(occs_sp, add = TRUE) #
set.seed(4594) # Set seed for random points for reproducibility#
background_points <- dismo::randomPoints(mask=clim, 200)
background_points#
#
plot(bioclim_na[[1]], main = "BIO1 - Annual Mean Temp (C)") #
points(background_points, pch = 21)
plot(occs_sp, add = TRUE)
plot(bioclim_na[[1]], main = "BIO1 - Annual Mean Temp (C)\n+=tick occurrences, O=pseudoabsences") #
plot(occs_sp, add = TRUE) #
points(background_points, pch = 21)
maxent_model <- maxent(clim, occs_sp, a = background_points)#
maxent_model#
plot(maxent_model)
bio1 = "AnnMeanTemp"#
bio2 = "MeanDiurnalRange_MeanMonthlyMaxT-MinT"#
bio3 = "Isothermality_Bio2divBio7×100"#
bio4 = "TempSeasonality_SD×100"#
bio5 = "MaxTempWarmestMon"#
bio6 = "MinTempColdestMon"#
bio7 = "Temp AnnRange_Bio5-Bio6"#
bio8 = "MeanTempWettestQuarter"#
bio9 = "MeanTempDriestQuarter"#
bio10 = "MeanTempWarmestQuarter"#
bio11 = "MeanTempColdestQuarter"#
bio12 = "AnnPrecip"#
bio13 = "PrecipWettestMon"#
bio14 = "PrecipDriestMon"#
bio15 = "PrecipSeasonalityCoefVar"#
bio16 = "PrecipWettestQuarter"#
bio17 = "PrecipDriestQuarter"#
bio18 = "PrecipWarmestQuarter"#
bio19 = "PrecipColdestQuarter"#
#
abbr = c(bio1,bio2,bio3,bio4,bio5,bio6,bio7,bio8,bio9,bio10,bio11,bio12,bio13,bio14,bio15,bio16,bio17,bio18,bio19)#
#
dput(abbr)
bioclim_data
names(bioclim_data)
names(bioclim_data) = abbr#
#
na_extent <- ext(-130, -60, 20, 55)  # North America extent#
bioclim_na <- crop(bioclim_data, na_extent)#
#
# Mask for randomPoints#
clim <- raster::stack(bioclim_na) #
#
# Plot WorldClim's Bio1: Annual Mean Temperature#
plot(bioclim_na[[1]], main = "BIO1 - Annual Mean Temp (C)") #
plot(occs_sp, add = TRUE) #
set.seed(4594) # Set seed for random points for reproducibility#
background_points <- dismo::randomPoints(mask=clim, 200)#
background_points#
#
plot(bioclim_na[[1]], main = "BIO1 - Annual Mean Temp (C)\n+=tick occurrences, o=pseudoabsences") #
plot(occs_sp, add = TRUE) #
points(background_points, pch = 21) #
#
# Build a Maxent model#
maxent_model <- maxent(clim, occs_sp, a = background_points)#
maxent_model#
plot(maxent_model)
abbr = c("bio1:AnnMeanTemp", "bio2:MeanDiurnalRange_MeanMonthlyMaxT-MinT", "bio3:Isothermality_Bio2divBio7×100", #
"bio4:TempSeasonality_SD×100", "bio5:MaxTempWarmestMon", "bio6:MinTempColdestMon", #
"bio7Temp AnnRange_Bio5-Bio6", "bi8:MeanTempWettestQuarter", "bio9:MeanTempDriestQuarter", #
"bio10MeanTempWarmestQuarter", "bio11:MeanTempColdestQuarter", "bio12:AnnPrecip", #
"bio13:PrecipWettestMon", "bio14:PrecipDriestMon", "bio15:PrecipSeasonalityCoefVar", #
"bio16:PrecipWettestQuarter", "bio17:PrecipDriestQuarter", "bio18:PrecipWarmestQuarter", #
"bio19:PrecipColdestQuarter")#
#
names(bioclim_data) = abbr#
#
na_extent <- ext(-130, -60, 20, 55)  # North America extent#
bioclim_na <- crop(bioclim_data, na_extent)#
#
# Mask for randomPoints#
clim <- raster::stack(bioclim_na) #
#
# Plot WorldClim's Bio1: Annual Mean Temperature#
plot(bioclim_na[[1]], main = "BIO1 - Annual Mean Temp (C)") #
plot(occs_sp, add = TRUE) #
set.seed(4594) # Set seed for random points for reproducibility#
background_points <- dismo::randomPoints(mask=clim, 200)#
background_points#
#
plot(bioclim_na[[1]], main = "BIO1 - Annual Mean Temp (C)\n+=tick occurrences, o=pseudoabsences") #
plot(occs_sp, add = TRUE) #
points(background_points, pch = 21) #
#
# Build a Maxent model#
maxent_model <- maxent(clim, occs_sp, a = background_points)#
maxent_model#
plot(maxent_model)
par(mfrow = c(2, 3))#
response_curves <- dismo::response(maxent_model, names(clim)[1:6])#
#
predict_suitability <- dismo::predict(maxent_model, clim)
par(mfrow = c(2, 2))#
response_curves <- dismo::response(maxent_model, names(clim)[c(1,12,14,9)])#
title("Response curves for top 4 predictors")
par(mfrow = c(2, 3))#
response_curves <- dismo::response(maxent_model, names(clim)[1:6])#
mtext("Response curves for bio1-bio6", outer=TRUE)
?mtext
par(mfrow = c(2, 3))#
response_curves <- dismo::response(maxent_model, names(clim)[1:6])#
mtext("Response curves for bio1-bio6", side=3, outer=TRUE)#
#
par(mfrow = c(2, 2))#
response_curves <- dismo::response(maxent_model, names(clim)[c(1,12,14,9)])#
mtext("Response curves for top 4 predictors", side=3, outer=TRUE)
## Visualizing Fitted Constraints from MaxEnt Model#
par(mfrow = c(2, 3))#
response_curves <- dismo::response(maxent_model, names(clim)[1:6])#
mtext("Response curves for bio1-bio6", side=3, line=-2, outer=TRUE)#
#
par(mfrow = c(2, 2))#
response_curves <- dismo::response(maxent_model, names(clim)[c(1,12,14,9)])#
mtext("Response curves for top 4 predictors", side=3, line=-2, outer=TRUE)
plot(bioclim_na[[1]], main = "BIO1 - Annual Mean Temp (C)\n+=tick occurrences, .=pseudoabsences") #
plot(occs_sp, add = TRUE) #
points(background_points, pch = ".")
par(mfrow=c(1,1))#
plot(bioclim_na[[1]], main = "BIO1 - Annual Mean Temp (C)\n+=tick occurrences, .=pseudoabsences") #
plot(occs_sp, add = TRUE) #
points(background_points, pch = ".")
# Build a Maxent model#
maxent_model <- maxent(clim, occs_sp, a = background_points)#
maxent_model#
plot(maxent_model)#
## Visualizing Fitted Constraints from MaxEnt Model#
par(mfrow = c(2, 3))#
response_curves <- dismo::response(maxent_model, names(clim)[1:6])#
mtext("Response curves for bio1-bio6", side=3, line=-2, outer=TRUE)#
#
par(mfrow = c(2, 2))#
response_curves <- dismo::response(maxent_model, names(clim)[c(1,12,14,9)])#
mtext("Response curves for top 4 predictors", side=3, line=-2, outer=TRUE)#
#
# Predict the suitability#
predict_suitability <- dismo::predict(maxent_model, clim)#
#
# Plot the suitability#
par(mfrow = c(1,1))#
plot(predict_suitability, main="MaxEnt Predicted Suitability for Lone Star Tick")
plot(occs_sp, add = TRUE) #
points(background_points, pch = ".")
par(mfrow = c(1,1))#
plot(predict_suitability, main="MaxEnt Predicted Suitability for Lone Star Tick\n+=tick occurrences, .=pseudoabsences")#
plot(occs_sp, add = TRUE) #
points(background_points, pch = ".")
auc <- dismo::evaluate(model = maxent_model, p=occs_sp@coords, a=background_points, x = clim)#
plot(auc, 'ROC')
auc
plot.ModelEvaluation(auc, 'ROC')
*dismo::plot.ModelEvaluation(auc, 'ROC')
dismo::plot.ModelEvaluation(auc, 'ROC')
class(auc)
? ModelEvaluation
?evaluate
fold <- kfold(occs_sp, k=5)#
occtest <- occs_sp[fold == 1, ]#
occtrain <- occs_sp[fold != 1, ]
train_model <- maxent(clim, occtrain, a = background_points)
auc_test <- dismo::evaluate(model = train_model, p=occtest@coords, a=background_points, x = clim)#
plot(auc_test, 'ROC')
set.seed(45698)#
background_test <- randomPoints(clim, 200)#
train_model <- maxent(clim, occtrain, a = background_points)#
auc_test <- dismo::evaluate(model = train_model, p=occtest@coords, a=background_test, x = clim)#
plot(auc_test, 'ROC')
species_name_2 <- "Anas platyrhynchos"#
gbif_data_2 <- occ_search(scientificName = species_name_2, limit = 50, hasCoordinate = TRUE, stateProvince = "Florida")#
occs_2 <- gbif_data_2$data[, c("decimalLongitude", "decimalLatitude")]
occs_sp_2 <- SpatialPointsDataFrame(coords = occs_2, data = data.frame(occs_2), proj4string = CRS("+proj=longlat +datum=WGS84"))
species_name_2 <- "Anas platyrhynchos"#
gbif_data_3 <- occ_search(scientificName = species_name_2, limit = 50, hasCoordinate = TRUE, stateProvince = "Michigan")#
occs_3 <- gbif_data_3$data[, c("decimalLongitude", "decimalLatitude")]
mallard_test <- SpatialPointsDataFrame(coords = occs_3, data = data.frame(occs_3), proj4string = CRS("+proj=longlat +datum=WGS84"))
auc_test <- dismo::evaluate(model = mall_mod, p=mallard_test@coords, a=background_points, x = clim)#
plot(auc_test, 'ROC')
background_points
train_model <- maxent(clim, occs_sp_2, a = background_points)#
#
auc_test <- dismo::evaluate(model = train_model, p=mallard_test@coords, a=background_points, x = clim)#
plot(auc_test, 'ROC')
predict_suitability <- dismo::predict(train_model, clim)#
#
# Plot the suitability#
par(mfrow = c(1,1))#
plot(predict_suitability, main="MaxEnt Predicted Suitability for Mallards (with Florida data)\n+=Florida training, .=pseudoabsences, x=Michigan test data")#
plot(occs_sp_2, add = TRUE) #
points(background_points, pch = ".") #
points(mallard_test, pch = "x")
abbr
occ_values <- terra::extract(clim, occtrain, df = TRUE)#
background_values <- terra::extract(clim, background_points, df = TRUE)#
#
occ_values$presence <- 1#
background_values$presence <- 0#
#
data_glm <- rbind(occ_values, background_values)#
data_glm <- na.omit(data_glm)  # Remove NA values
data_glm
names(data_glm)
glm_model <- glm(presence ~ bio1.AnnMeanTemp + bio5.MaxTempWarmestMon, data=data_glm, family=binomial)#
summary(glm_model)
occ_values
predicted_raster <- dismo::predict(bioclim_na, glm_model, type = "response")#
plot(predicted_raster, main = "Predicted Lone Star Tick Prob. from GLM")
glm_model <- glm(presence ~ wc2.1_2.5m_bio_1 + wc2.1_2.5m_bio_5 , data = data_glm, family = binomial)
data_glm
dim(data_glm)
names(data_glm)
glm_model <- glm(presence ~ bio1.AnnMeanTemp + bio5.MaxTempWarmestMon, data=data_glm, family=binomial)
summary(glm_model)
bioclim_na
names(bioclim_na)
names(bioclim_na) = gsub(pattern=":", replacement=".", x=names(bioclim_na))#
predicted_raster <- dismo::predict(bioclim_na, glm_model, type = "response")#
plot(predicted_raster, main = "Predicted Lone Star Tick Prob. from GLM")
test_values <- terra::extract(clim, occtest, df = TRUE)#
background_test2 <- terra::extract(clim, background_test, df = TRUE)
test_values$presence <- 1#
background_test2$presence <- 0#
#
data_glm_test <- rbind(test_values, background_test2)#
data_glm_test <- na.omit(data_glm_test)  # Remove NA values
glm_pred <- dismo::predict(glm_model, newdata = data_glm_test, type = "response")#
glm_auc <- pROC::roc(data_glm_test$presence, glm_pred)#
plot(glm_auc, main="ROC Curve for GLM Model")#
glm_auc$auc
background_values
occtrain
names(bioclim_na) = gsub(pattern=":", replacement=".", x=names(bioclim_na))#
predicted_raster <- dismo::predict(bioclim_na, glm_model, type = "response")#
plot(predicted_raster, main = "Predicted Lone Star Tick Probability, from GLM\n+=tick occurrences, .=pseudoabsences")#
plot(occtrain, add = TRUE) #
points(background_points, pch = ".")
# Assess with a test dataset#
test_values <- terra::extract(clim, occtest, df = TRUE)#
background_test2 <- terra::extract(clim, background_test, df = TRUE)#
#
test_values$presence <- 1#
background_test2$presence <- 0#
#
data_glm_test <- rbind(test_values, background_test2)#
data_glm_test <- na.omit(data_glm_test)  # Remove NA values#
#
# Predict the test dataset#
glm_pred <- dismo::predict(glm_model, newdata = data_glm_test, type = "response")#
glm_auc <- pROC::roc(data_glm_test$presence, glm_pred)#
plot(glm_auc, main="ROC Curve for GLM Model")#
glm_auc$auc
# Extract comparison metrics#
comparison_metrics <- data.frame(#
  Model = c("MaxEnt", "GLM"),#
  AUC = c(auc@auc, glm_auc$auc)#
)#
#
ggplot(comparison_metrics, aes(x=Model, y=AUC, fill=Model)) +#
  geom_bar(stat="identity") +#
  theme_minimal() +#
  ggtitle("AUC Comparison: MaxEnt vs. GLM")
ggplot(comparison_metrics, aes(x=Model, y=AUC, fill=Model)) +#
  geom_bar(stat="identity") +#
  theme_minimal() +#
  ggtitle("Lone Star Tick predictions: AUC Comparison: MaxEnt vs. GLM")
rf_model <- randomForest(as.factor(presence) ~ ., data = data_glm[,-1], importance = TRUE)#
print(rf_model)
importance(rf_model)#
varImpPlot(rf_model)#
#
predicted_rf <- predict(clim, rf_model, type = "prob", index = 2)
par(mfrow=c(1,1))#
predicted_rf <- predict(clim, rf_model, type = "prob", index = 2)
rf_model <- randomForest(as.factor(presence) ~ ., data = data_glm[,-1], importance = TRUE)#
print(rf_model)
importance(rf_model)
varImpPlot(rf_model)
importance(rf_model)
varImpPlot
varImpPlot(rf_model, sort=FALSE, cex=0.5)
varImpPlot(rf_model, sort=FALSE, cex=0.7)
predicted_rf <- predict(clim, rf_model, type = "prob", index = 2)#
rf_pred <- predict(rf_model, newdata = data_glm_test[,-1], type = "prob")[, 2]#
rf_auc <- roc(data_glm_test[,-1]$presence, rf_pred)#
print(rf_auc$auc)
comparison_metrics <- data.frame(#
  Model = c("MaxEnt", "GLM", "RF"),#
  AUC = c(auc@auc, glm_auc$auc, rf_auc$auc)#
)#
ggplot(comparison_metrics, aes(x = Model, y = AUC, fill = Model)) +#
  geom_bar(stat = "identity") +#
  theme_minimal() +#
  ggtitle("Lone Star Tick projections: AUC Comparison: MaxEnt vs. GLM vs. RF") +#
  ylim(0, 1)  # set limits to the probability range (0-1)
future2070 <- cmip6_world(var = "bioc", res = 2.5, model = "ACCESS-CM2", ssp = 245, time = "2061-2080", path = tempdir())#
na_extent <- ext(-130, -60, 20, 55)  # North America extent#
future_na <- crop(future2070, na_extent)
manual_temp <- bioclim_na[[1]] + 2
temp_change <- future_na[[1]] - bioclim_na[[1]]
par(mfrow=c(2,2))#
plot(bioclim_na[[1]], main = "Bio1: Annual Mean Temp (C)") #
plot(future_na[[1]], main = "Bio1 2070 RCP 4.5: Ann Temp (C)") #
plot(manual_temp, main = "Bio1: Temp (C) + 2") #
plot(temp_change, main = "Bio1 2070 RCP 4.5: Change in Temp (C)") #
mtext("Current and future mean annual temperature (Bio1)", side=3, line=-2, outer=TRUE)
# Modified from:#
# https://bookdown.org/pjhanly/fw840hanly/week-4-species-distribution-models.html#
setup_run_once='#
install.packages("rgbif")#
install.packages("dismo") # SDM package#
install.packages("rJava") # Java for MaxEnt. If this doesnt install properly, download the proper Java Development Kit for your OS and bit version here: https://www.oracle.com/java/technologies/downloads/?er=221886#
install.packages("raster")#
install.packages("sf")#
install.packages("ggplot2")#
install.packages("geodata")#
install.packages("terra")#
install.packages("spatstat")#
install.packages("pROC") # Calculates ROC for GLM#
install.packages("MASS")#
install.packages("randomForest") # Random forest package#
'#
library(rgbif)#
library(dismo) # SDM package#
library(rJava) # Java for MaxEnt. #
# If this doesn't install properly, download the proper #
# Java Development Kit for your OS and bit version #
# here: https://www.oracle.com/java/technologies/downloads/?er=221886#
library(raster)#
library(sf)#
library(ggplot2)#
library(geodata)#
library(terra)#
library(spatstat)#
library(pROC) # Calculates ROC for GLM#
library(MASS)#
library(randomForest) # Random forest package#
#
# Lone star tick, from eastern USA#
# ("Lone Star State" = Texas)#
species_name <- "Amblyomma americanum "#
gbif_data <- rgbif::occ_search(scientificName = species_name, limit = 200, hasCoordinate = TRUE)#
#
occs <- gbif_data$data[, c("decimalLongitude", "decimalLatitude")]#
head(occs)#
#
# Convert to SpatialPointsDataFrame format#
occs_sp <- sp::SpatialPointsDataFrame(coords = occs, data = data.frame(occs), proj4string = CRS("+proj=longlat +datum=WGS84"))#
#
# Download climate layers from WorldClim#
bioclim_data <- worldclim_global(var="bio", res=2.5, path=tempdir())#
#
################################################
# Bioclimatic variables#
# https://www.worldclim.org/data/bioclim.html#
# bio1 = Annual Mean Temperature#
# bio2 = Mean Diurnal Range (Mean of monthly (max temp - min temp))#
# bio3 = Isothermality (bio2/bio7) (×100)#
# bio4 = Temperature Seasonality (standard deviation ×100)#
# bio5 = Max Temperature of Warmest Month#
# bio6 = Min Temperature of Coldest Month#
# bio7 = Temperature Annual Range (bio5-bio6)#
# bio8 = Mean Temperature of Wettest Quarter#
# bio9 = Mean Temperature of Driest Quarter#
# bio10 = Mean Temperature of Warmest Quarter#
# bio11 = Mean Temperature of Coldest Quarter#
# bio12 = Annual Precipitation#
# bio13 = Precipitation of Wettest Month#
# bio14 = Precipitation of Driest Month#
# bio15 = Precipitation Seasonality (Coefficient of Variation)#
# bio16 = Precipitation of Wettest Quarter#
# bio17 = Precipitation of Driest Quarter#
# bio18 = Precipitation of Warmest Quarter#
# bio19 = Precipitation of Coldest Quarter#
################################################
#
# Better abbreviations for bioclim_data in R#
abbr = c("bio1:AnnMeanTemp", "bio2:MeanDiurnalRange_MeanMonthlyMaxT-MinT", "bio3:Isothermality_Bio2divBio7×100", #
"bio4:TempSeasonality_SD×100", "bio5:MaxTempWarmestMon", "bio6:MinTempColdestMon", #
"bio7Temp AnnRange_Bio5-Bio6", "bi8:MeanTempWettestQuarter", "bio9:MeanTempDriestQuarter", #
"bio10MeanTempWarmestQuarter", "bio11:MeanTempColdestQuarter", "bio12:AnnPrecip", #
"bio13:PrecipWettestMon", "bio14:PrecipDriestMon", "bio15:PrecipSeasonalityCoefVar", #
"bio16:PrecipWettestQuarter", "bio17:PrecipDriestQuarter", "bio18:PrecipWarmestQuarter", #
"bio19:PrecipColdestQuarter")#
#
names(bioclim_data) = abbr#
#
na_extent <- ext(-130, -60, 20, 55)  # North America extent#
bioclim_na <- crop(bioclim_data, na_extent)#
#
# Mask for randomPoints#
clim <- raster::stack(bioclim_na) #
#
pdffn = "731_SDM_intro_with_dismo_v2.pdf"#
pdf(file=pdffn, width=9, height=9)#
# Plot WorldClim's Bio1: Annual Mean Temperature#
plot(bioclim_na[[1]], main = "BIO1 - Annual Mean Temp (C)") #
plot(occs_sp, add = TRUE) #
set.seed(4594) # Set seed for random points for reproducibility#
background_points <- dismo::randomPoints(mask=clim, 200)#
background_points#
#
par(mfrow=c(1,1))#
plot(bioclim_na[[1]], main = "BIO1 - Annual Mean Temp (C)\n+=tick occurrences, .=pseudoabsences") #
plot(occs_sp, add = TRUE) #
points(background_points, pch = ".") #
#
# Build a Maxent model#
maxent_model <- maxent(clim, occs_sp, a = background_points)#
maxent_model#
plot(maxent_model)#
## Visualizing Fitted Constraints from MaxEnt Model#
par(mfrow = c(2, 3))#
response_curves <- dismo::response(maxent_model, names(clim)[1:6])#
mtext("Response curves for bio1-bio6", side=3, line=-2, outer=TRUE)#
#
par(mfrow = c(2, 2))#
response_curves <- dismo::response(maxent_model, names(clim)[c(1,12,14,9)])#
mtext("Response curves for top 4 predictors", side=3, line=-2, outer=TRUE)#
#
# Predict the suitability#
predict_suitability <- dismo::predict(maxent_model, clim)#
#
# Plot the suitability#
par(mfrow = c(1,1))#
plot(predict_suitability, main="MaxEnt Predicted Suitability for Lone Star Tick\n+=tick occurrences, .=pseudoabsences")#
plot(occs_sp, add = TRUE) #
points(background_points, pch = ".") #
# AUC: Area Under Curve#
auc <- dismo::evaluate(model = maxent_model, p=occs_sp@coords, a=background_points, x = clim)#
plot(auc, 'ROC')#
# Training vs. Test data#
# aka cross-validation#
fold <- kfold(occs_sp, k=5)#
occtest <- occs_sp[fold == 1, ]#
occtrain <- occs_sp[fold != 1, ]#
#
# Buid a model just on the training data#
train_model <- maxent(clim, occtrain, a = background_points)#
#
auc_test <- dismo::evaluate(model = train_model, p=occtest@coords, a=background_points, x = clim)#
plot(auc_test, 'ROC')#
#
# How well does the model work on the Test data?#
set.seed(45698)#
background_test <- randomPoints(clim, 200)#
train_model <- maxent(clim, occtrain, a = background_points)#
auc_test <- dismo::evaluate(model = train_model, p=occtest@coords, a=background_test, x = clim)#
plot(auc_test, 'ROC')#
# A bad MaxEnt model#
#
# Anas platyrhynchos = Mallard ducks#
species_name_2 <- "Anas platyrhynchos"#
#
# Gather occurrence data from just Florida#
gbif_data_2 <- occ_search(scientificName = species_name_2, limit = 50, hasCoordinate = TRUE, stateProvince = "Florida")#
occs_2 <- gbif_data_2$data[, c("decimalLongitude", "decimalLatitude")]#
#
occs_sp_2 <- SpatialPointsDataFrame(coords = occs_2, data = data.frame(occs_2), proj4string = CRS("+proj=longlat +datum=WGS84"))#
#
# Gather occurrence data from just Michigan#
species_name_2 <- "Anas platyrhynchos"#
gbif_data_3 <- occ_search(scientificName = species_name_2, limit = 50, hasCoordinate = TRUE, stateProvince = "Michigan")#
occs_3 <- gbif_data_3$data[, c("decimalLongitude", "decimalLatitude")]#
occs_sp_3 <- SpatialPointsDataFrame(coords = occs_3, data = data.frame(occs_3), #
#
# Construct a test dataset on the Michigan-only Mallard occurrences#
mallard_test <- SpatialPointsDataFrame(coords = occs_3, data = data.frame(occs_3), proj4string = CRS("+proj=longlat +datum=WGS84"))#
#
# Train model on the Mallard occurrence points from just Florida#
train_model <- maxent(clim, occs_sp_2, a = background_points)#
#
auc_test <- dismo::evaluate(model = train_model, p=mallard_test@coords, a=background_points, x = clim)#
plot(auc_test, 'ROC')#
# Predict the suitability for mallards#
predict_suitability <- dismo::predict(train_model, clim)#
#
# Plot the suitability#
par(mfrow = c(1,1))#
plot(predict_suitability, main="MaxEnt Predicted Suitability for Mallards (with Florida data)\n+=Florida training, .=pseudoabsences, x=Michigan test data")#
plot(occs_sp_2, add = TRUE) #
points(background_points, pch = ".") #
points(mallard_test, pch = "x") #
# GLM = Generalized Linear Model#
#
occ_values <- terra::extract(clim, occtrain, df = TRUE)#
background_values <- terra::extract(clim, background_points, df = TRUE)#
#
occ_values$presence <- 1#
background_values$presence <- 0#
#
data_glm <- rbind(occ_values, background_values)#
data_glm <- na.omit(data_glm)  # Remove NA values#
#
#glm_model <- glm(presence ~ wc2.1_2.5m_bio_1 + wc2.1_2.5m_bio_5 , data = data_glm, family = binomial)#
glm_model <- glm(presence ~ bio1.AnnMeanTemp + bio5.MaxTempWarmestMon, data=data_glm, family=binomial)#
summary(glm_model)#
#
# Predict with a GLM#
# Change names in bioclim_na#
names(bioclim_na) = gsub(pattern=":", replacement=".", x=names(bioclim_na))#
predicted_raster <- dismo::predict(bioclim_na, glm_model, type = "response")#
plot(predicted_raster, main = "Predicted Lone Star Tick Probability, from GLM\n+=tick occurrences, .=pseudoabsences")#
plot(occtrain, add = TRUE) #
points(background_points, pch = ".") #
# Assess with a test dataset#
test_values <- terra::extract(clim, occtest, df = TRUE)#
background_test2 <- terra::extract(clim, background_test, df = TRUE)#
#
test_values$presence <- 1#
background_test2$presence <- 0#
#
data_glm_test <- rbind(test_values, background_test2)#
data_glm_test <- na.omit(data_glm_test)  # Remove NA values#
#
# Predict the test dataset#
glm_pred <- dismo::predict(glm_model, newdata = data_glm_test, type = "response")#
glm_auc <- pROC::roc(data_glm_test$presence, glm_pred)#
plot(glm_auc, main="ROC Curve for GLM Model")#
glm_auc$auc#
# Area under the curve: 0.766#
#
# Extract comparison metrics#
comparison_metrics <- data.frame(#
  Model = c("MaxEnt", "GLM"),#
  AUC = c(auc@auc, glm_auc$auc)#
)#
#
ggplot(comparison_metrics, aes(x=Model, y=AUC, fill=Model)) +#
  geom_bar(stat="identity") +#
  theme_minimal() +#
  ggtitle("Lone Star Tick predictions: AUC Comparison: MaxEnt vs. GLM")#
########################################################
# Fit the randomForest model using all predictors, removing the ID column 1#
########################################################
rf_model <- randomForest(as.factor(presence) ~ ., data = data_glm[,-1], importance = TRUE)#
print(rf_model)#
#
importance(rf_model)#
varImpPlot(rf_model, sort=FALSE, cex=0.7)#
predicted_rf <- predict(clim, rf_model, type = "prob", index = 2)#
rf_pred <- predict(rf_model, newdata = data_glm_test[,-1], type = "prob")[, 2]#
rf_auc <- roc(data_glm_test[,-1]$presence, rf_pred)#
print(rf_auc$auc)#
# Area under the curve: 0.9626#
#
comparison_metrics <- data.frame(#
  Model = c("MaxEnt", "GLM", "RF"),#
  AUC = c(auc@auc, glm_auc$auc, rf_auc$auc)#
)#
ggplot(comparison_metrics, aes(x = Model, y = AUC, fill = Model)) +#
  geom_bar(stat = "identity") +#
  theme_minimal() +#
  ggtitle("Lone Star Tick projections: AUC Comparison: MaxEnt vs. GLM vs. RF") +#
  ylim(0, 1)  # set limits to the probability range (0-1)#
# Updated code for bringing in a 2070 climate scenario. #
# There are different models and scenarios you can check out #
# under the function description#
future2070 <- cmip6_world(var = "bioc", res = 2.5, model = "ACCESS-CM2", ssp = 245, time = "2061-2080", path = tempdir())#
na_extent <- ext(-130, -60, 20, 55)  # North America extent#
future_na <- crop(future2070, na_extent)#
#
# Manual add 2 to the original annual temperature raster from the exericse#
manual_temp <- bioclim_na[[1]] + 2#
#
# Calculate difference between the 2070 and current climate model for the annual temperature raster#
temp_change <- future_na[[1]] - bioclim_na[[1]]#
#
# Plot to show current annual temp, future annual temp, the manual difference raster, and the difference between current and future#
par(mfrow=c(2,2))#
plot(bioclim_na[[1]], main = "Bio1: Annual Mean Temp (C)") #
plot(future_na[[1]], main = "Bio1 2070 RCP 4.5: Ann Temp (C)") #
plot(manual_temp, main = "Bio1: Temp (C) + 2") #
plot(temp_change, main = "Bio1 2070 RCP 4.5: Change in Temp (C)") #
mtext("Current and future mean annual temperature (Bio1)", side=3, line=-2, outer=TRUE)#
dev.off()#
cmdstr = paste0("open ", pdffn)#
system(cmdstr)
species_name_2 <- "Anas platyrhynchos"#
#
# Gather occurrence data from just Florida#
gbif_data_2 <- occ_search(scientificName = species_name_2, limit = 50, hasCoordinate = TRUE, stateProvince = "Florida")#
occs_2 <- gbif_data_2$data[, c("decimalLongitude", "decimalLatitude")]#
#
occs_sp_2 <- SpatialPointsDataFrame(coords = occs_2, data = data.frame(occs_2), proj4string = CRS("+proj=longlat +datum=WGS84"))#
#
# Gather occurrence data from just Michigan#
species_name_2 <- "Anas platyrhynchos"#
gbif_data_3 <- occ_search(scientificName = species_name_2, limit = 50, hasCoordinate = TRUE, stateProvince = "Michigan")#
occs_3 <- gbif_data_3$data[, c("decimalLongitude", "decimalLatitude")]#
occs_sp_3 <- SpatialPointsDataFrame(coords = occs_3, data = data.frame(occs_3), #
#
# Construct a test dataset on the Michigan-only Mallard occurrences#
mallard_test <- SpatialPointsDataFrame(coords = occs_3, data = data.frame(occs_3), proj4string = CRS("+proj=longlat +datum=WGS84"))#
#
# Train model on the Mallard occurrence points from just Florida#
train_model <- maxent(clim, occs_sp_2, a = background_points)#
#
auc_test <- dismo::evaluate(model = train_model, p=mallard_test@coords, a=background_points, x = clim)#
plot(auc_test, 'ROC')#
# Predict the suitability for mallards#
predict_suitability <- dismo::predict(train_model, clim)#
#
# Plot the suitability#
par(mfrow = c(1,1))#
plot(predict_suitability, main="MaxEnt Predicted Suitability for Mallards (with Florida data)\n+=Florida training, .=pseudoabsences, x=Michigan test data")#
plot(occs_sp_2, add = TRUE) #
points(background_points, pch = ".") #
points(mallard_test, pch = "x")
dev.off()
# Modified from:#
# https://bookdown.org/pjhanly/fw840hanly/week-4-species-distribution-models.html#
setup_run_once='#
install.packages("rgbif")#
install.packages("dismo") # SDM package#
install.packages("rJava") # Java for MaxEnt. If this doesnt install properly, download the proper Java Development Kit for your OS and bit version here: https://www.oracle.com/java/technologies/downloads/?er=221886#
install.packages("raster")#
install.packages("sf")#
install.packages("ggplot2")#
install.packages("geodata")#
install.packages("terra")#
install.packages("spatstat")#
install.packages("pROC") # Calculates ROC for GLM#
install.packages("MASS")#
install.packages("randomForest") # Random forest package#
'#
library(rgbif)#
library(dismo) # SDM package#
library(rJava) # Java for MaxEnt. #
# If this doesn't install properly, download the proper #
# Java Development Kit for your OS and bit version #
# here: https://www.oracle.com/java/technologies/downloads/?er=221886#
library(raster)#
library(sf)#
library(ggplot2)#
library(geodata)#
library(terra)#
library(spatstat)#
library(pROC) # Calculates ROC for GLM#
library(MASS)#
library(randomForest) # Random forest package#
#
# Lone star tick, from eastern USA#
# ("Lone Star State" = Texas)#
species_name <- "Amblyomma americanum "#
gbif_data <- rgbif::occ_search(scientificName = species_name, limit = 200, hasCoordinate = TRUE)#
#
occs <- gbif_data$data[, c("decimalLongitude", "decimalLatitude")]#
head(occs)#
#
# Convert to SpatialPointsDataFrame format#
occs_sp <- sp::SpatialPointsDataFrame(coords = occs, data = data.frame(occs), proj4string = CRS("+proj=longlat +datum=WGS84"))#
#
# Download climate layers from WorldClim#
bioclim_data <- worldclim_global(var="bio", res=2.5, path=tempdir())#
#
################################################
# Bioclimatic variables#
# https://www.worldclim.org/data/bioclim.html#
# bio1 = Annual Mean Temperature#
# bio2 = Mean Diurnal Range (Mean of monthly (max temp - min temp))#
# bio3 = Isothermality (bio2/bio7) (×100)#
# bio4 = Temperature Seasonality (standard deviation ×100)#
# bio5 = Max Temperature of Warmest Month#
# bio6 = Min Temperature of Coldest Month#
# bio7 = Temperature Annual Range (bio5-bio6)#
# bio8 = Mean Temperature of Wettest Quarter#
# bio9 = Mean Temperature of Driest Quarter#
# bio10 = Mean Temperature of Warmest Quarter#
# bio11 = Mean Temperature of Coldest Quarter#
# bio12 = Annual Precipitation#
# bio13 = Precipitation of Wettest Month#
# bio14 = Precipitation of Driest Month#
# bio15 = Precipitation Seasonality (Coefficient of Variation)#
# bio16 = Precipitation of Wettest Quarter#
# bio17 = Precipitation of Driest Quarter#
# bio18 = Precipitation of Warmest Quarter#
# bio19 = Precipitation of Coldest Quarter#
################################################
#
# Better abbreviations for bioclim_data in R#
abbr = c("bio1:AnnMeanTemp", "bio2:MeanDiurnalRange_MeanMonthlyMaxT-MinT", "bio3:Isothermality_Bio2divBio7×100", #
"bio4:TempSeasonality_SD×100", "bio5:MaxTempWarmestMon", "bio6:MinTempColdestMon", #
"bio7Temp AnnRange_Bio5-Bio6", "bi8:MeanTempWettestQuarter", "bio9:MeanTempDriestQuarter", #
"bio10MeanTempWarmestQuarter", "bio11:MeanTempColdestQuarter", "bio12:AnnPrecip", #
"bio13:PrecipWettestMon", "bio14:PrecipDriestMon", "bio15:PrecipSeasonalityCoefVar", #
"bio16:PrecipWettestQuarter", "bio17:PrecipDriestQuarter", "bio18:PrecipWarmestQuarter", #
"bio19:PrecipColdestQuarter")#
#
names(bioclim_data) = abbr#
#
na_extent <- ext(-130, -60, 20, 55)  # North America extent#
bioclim_na <- crop(bioclim_data, na_extent)#
#
# Mask for randomPoints#
clim <- raster::stack(bioclim_na) #
#
pdffn = "731_SDM_intro_with_dismo_v2.pdf"#
pdf(file=pdffn, width=9, height=9)#
# Plot WorldClim's Bio1: Annual Mean Temperature#
plot(bioclim_na[[1]], main = "BIO1 - Annual Mean Temp (C)") #
plot(occs_sp, add = TRUE) #
set.seed(4594) # Set seed for random points for reproducibility#
background_points <- dismo::randomPoints(mask=clim, 200)#
background_points#
#
par(mfrow=c(1,1))#
plot(bioclim_na[[1]], main = "BIO1 - Annual Mean Temp (C)\n+=tick occurrences, .=pseudoabsences") #
plot(occs_sp, add = TRUE) #
points(background_points, pch = ".") #
#
# Build a Maxent model#
maxent_model <- maxent(clim, occs_sp, a = background_points)#
maxent_model#
plot(maxent_model)#
## Visualizing Fitted Constraints from MaxEnt Model#
par(mfrow = c(2, 3))#
response_curves <- dismo::response(maxent_model, names(clim)[1:6])#
mtext("Response curves for bio1-bio6", side=3, line=-2, outer=TRUE)#
#
par(mfrow = c(2, 2))#
response_curves <- dismo::response(maxent_model, names(clim)[c(1,12,14,9)])#
mtext("Response curves for top 4 predictors", side=3, line=-2, outer=TRUE)#
#
# Predict the suitability#
predict_suitability <- dismo::predict(maxent_model, clim)#
#
# Plot the suitability#
par(mfrow = c(1,1))#
plot(predict_suitability, main="MaxEnt Predicted Suitability for Lone Star Tick\n+=tick occurrences, .=pseudoabsences")#
plot(occs_sp, add = TRUE) #
points(background_points, pch = ".") #
# AUC: Area Under Curve#
auc <- dismo::evaluate(model = maxent_model, p=occs_sp@coords, a=background_points, x = clim)#
plot(auc, 'ROC')#
# Training vs. Test data#
# aka cross-validation#
fold <- kfold(occs_sp, k=5)#
occtest <- occs_sp[fold == 1, ]#
occtrain <- occs_sp[fold != 1, ]#
#
# Buid a model just on the training data#
train_model <- maxent(clim, occtrain, a = background_points)#
#
auc_test <- dismo::evaluate(model = train_model, p=occtest@coords, a=background_points, x = clim)#
plot(auc_test, 'ROC')#
#
# How well does the model work on the Test data?#
set.seed(45698)#
background_test <- randomPoints(clim, 200)#
train_model <- maxent(clim, occtrain, a = background_points)#
auc_test <- dismo::evaluate(model = train_model, p=occtest@coords, a=background_test, x = clim)#
plot(auc_test, 'ROC')#
# A bad MaxEnt model#
#
# Anas platyrhynchos = Mallard ducks#
species_name_2 <- "Anas platyrhynchos"#
#
# Gather occurrence data from just Florida#
gbif_data_2 <- occ_search(scientificName = species_name_2, limit = 50, hasCoordinate = TRUE, stateProvince = "Florida")#
occs_2 <- gbif_data_2$data[, c("decimalLongitude", "decimalLatitude")]#
#
occs_sp_2 <- SpatialPointsDataFrame(coords = occs_2, data = data.frame(occs_2), proj4string = CRS("+proj=longlat +datum=WGS84"))#
#
# Gather occurrence data from just Michigan#
species_name_2 <- "Anas platyrhynchos"#
gbif_data_3 <- occ_search(scientificName = species_name_2, limit = 50, hasCoordinate = TRUE, stateProvince = "Michigan")#
occs_3 <- gbif_data_3$data[, c("decimalLongitude", "decimalLatitude")]#
occs_sp_3 <- SpatialPointsDataFrame(coords = occs_3, data = data.frame(occs_3), proj4string = CRS("+proj=longlat +datum=WGS84"))#
#
# Construct a test dataset on the Michigan-only Mallard occurrences#
mallard_test <- SpatialPointsDataFrame(coords = occs_3, data = data.frame(occs_3), proj4string = CRS("+proj=longlat +datum=WGS84"))#
#
# Train model on the Mallard occurrence points from just Florida#
train_model <- maxent(clim, occs_sp_2, a = background_points)#
#
auc_test <- dismo::evaluate(model = train_model, p=mallard_test@coords, a=background_points, x = clim)#
plot(auc_test, 'ROC')#
# Predict the suitability for mallards#
predict_suitability <- dismo::predict(train_model, clim)#
#
# Plot the suitability#
par(mfrow = c(1,1))#
plot(predict_suitability, main="MaxEnt Predicted Suitability for Mallards (with Florida data)\n+=Florida training, .=pseudoabsences, x=Michigan test data")#
plot(occs_sp_2, add = TRUE) #
points(background_points, pch = ".") #
points(mallard_test, pch = "x") #
# GLM = Generalized Linear Model#
#
occ_values <- terra::extract(clim, occtrain, df = TRUE)#
background_values <- terra::extract(clim, background_points, df = TRUE)#
#
occ_values$presence <- 1#
background_values$presence <- 0#
#
data_glm <- rbind(occ_values, background_values)#
data_glm <- na.omit(data_glm)  # Remove NA values#
#
#glm_model <- glm(presence ~ wc2.1_2.5m_bio_1 + wc2.1_2.5m_bio_5 , data = data_glm, family = binomial)#
glm_model <- glm(presence ~ bio1.AnnMeanTemp + bio5.MaxTempWarmestMon, data=data_glm, family=binomial)#
summary(glm_model)#
#
# Predict with a GLM#
# Change names in bioclim_na#
names(bioclim_na) = gsub(pattern=":", replacement=".", x=names(bioclim_na))#
predicted_raster <- dismo::predict(bioclim_na, glm_model, type = "response")#
plot(predicted_raster, main = "Predicted Lone Star Tick Probability, from GLM\n+=tick occurrences, .=pseudoabsences")#
plot(occtrain, add = TRUE) #
points(background_points, pch = ".") #
# Assess with a test dataset#
test_values <- terra::extract(clim, occtest, df = TRUE)#
background_test2 <- terra::extract(clim, background_test, df = TRUE)#
#
test_values$presence <- 1#
background_test2$presence <- 0#
#
data_glm_test <- rbind(test_values, background_test2)#
data_glm_test <- na.omit(data_glm_test)  # Remove NA values#
#
# Predict the test dataset#
glm_pred <- dismo::predict(glm_model, newdata = data_glm_test, type = "response")#
glm_auc <- pROC::roc(data_glm_test$presence, glm_pred)#
plot(glm_auc, main="ROC Curve for GLM Model")#
glm_auc$auc#
# Area under the curve: 0.766#
#
# Extract comparison metrics#
comparison_metrics <- data.frame(#
  Model = c("MaxEnt", "GLM"),#
  AUC = c(auc@auc, glm_auc$auc)#
)#
#
ggplot(comparison_metrics, aes(x=Model, y=AUC, fill=Model)) +#
  geom_bar(stat="identity") +#
  theme_minimal() +#
  ggtitle("Lone Star Tick predictions: AUC Comparison: MaxEnt vs. GLM")#
########################################################
# Fit the randomForest model using all predictors, removing the ID column 1#
########################################################
rf_model <- randomForest(as.factor(presence) ~ ., data = data_glm[,-1], importance = TRUE)#
print(rf_model)#
#
importance(rf_model)#
varImpPlot(rf_model, sort=FALSE, cex=0.7)#
predicted_rf <- predict(clim, rf_model, type = "prob", index = 2)#
rf_pred <- predict(rf_model, newdata = data_glm_test[,-1], type = "prob")[, 2]#
rf_auc <- roc(data_glm_test[,-1]$presence, rf_pred)#
print(rf_auc$auc)#
# Area under the curve: 0.9626#
#
comparison_metrics <- data.frame(#
  Model = c("MaxEnt", "GLM", "RF"),#
  AUC = c(auc@auc, glm_auc$auc, rf_auc$auc)#
)#
ggplot(comparison_metrics, aes(x = Model, y = AUC, fill = Model)) +#
  geom_bar(stat = "identity") +#
  theme_minimal() +#
  ggtitle("Lone Star Tick projections: AUC Comparison: MaxEnt vs. GLM vs. RF") +#
  ylim(0, 1)  # set limits to the probability range (0-1)#
# Updated code for bringing in a 2070 climate scenario. #
# There are different models and scenarios you can check out #
# under the function description#
future2070 <- cmip6_world(var = "bioc", res = 2.5, model = "ACCESS-CM2", ssp = 245, time = "2061-2080", path = tempdir())#
na_extent <- ext(-130, -60, 20, 55)  # North America extent#
future_na <- crop(future2070, na_extent)#
#
# Manual add 2 to the original annual temperature raster from the exericse#
manual_temp <- bioclim_na[[1]] + 2#
#
# Calculate difference between the 2070 and current climate model for the annual temperature raster#
temp_change <- future_na[[1]] - bioclim_na[[1]]#
#
# Plot to show current annual temp, future annual temp, the manual difference raster, and the difference between current and future#
par(mfrow=c(2,2))#
plot(bioclim_na[[1]], main = "Bio1: Annual Mean Temp (C)") #
plot(future_na[[1]], main = "Bio1 2070 RCP 4.5: Ann Temp (C)") #
plot(manual_temp, main = "Bio1: Temp (C) + 2") #
plot(temp_change, main = "Bio1 2070 RCP 4.5: Change in Temp (C)") #
mtext("Current and future mean annual temperature (Bio1)", side=3, line=-2, outer=TRUE)#
dev.off()#
cmdstr = paste0("open ", pdffn)#
system(cmdstr)
2029.26*2
library(ape)#
library(optimx)   # optimx seems better than R's default optim()#
library(GenSA)    # GenSA seems better than optimx (but slower) on 5+ parameters, #
                  # seems to sometimes fail on simple problems (2-3 parameters)#
library(rexpokit)#
library(cladoRcpp)#
library(snow)     # (if you want to use multicore functionality; some systems/R versions prefer library(parallel), try either)#
library(parallel)#
library(BioGeoBEARS)#
#
########################################################
# SETUP: YOUR WORKING DIRECTORY#
########################################################
# You will need to set your working directory to match your local system#
#
# Note these very handy functions!#
# Command "setwd(x)" sets your working directory#
# Command "getwd()" gets your working directory and tells you what it is.#
# Command "list.files()" lists the files in your working directory#
# To get help on any command, use "?".  E.g., "?list.files"#
#
# Set your working directory for output files#
# default here is your home directory ("~")#
# Change this as you like#
wd = np("~")#
setwd(wd)#
#
# Double-check your working directory with getwd()#
getwd()#
#
########################################################
# SETUP: Extension data directory#
########################################################
# When R packages contain extra files, they are stored in the "extdata" directory #
# inside the installed package.#
##
# BioGeoBEARS contains various example files and scripts in its extdata directory.#
# #
# Each computer operating system might install BioGeoBEARS in a different place, #
# depending on your OS and settings. #
# #
# However, you can find the extdata directory like this:#
extdata_dir = np(system.file("extdata", package="BioGeoBEARS"))#
extdata_dir#
list.files(extdata_dir)#
#
# "system.file" looks in the directory of a specified package (in this case BioGeoBEARS)#
# The function "np" is just a shortcut for normalizePath(), which converts the #
# path to the format appropriate for your system (e.g., Mac/Linux use "/", but #
# Windows uses "\\", if memory serves).#
#
# Even when using your own data files, you should KEEP these commands in your #
# script, since the plot_BioGeoBEARS_results function needs a script from the #
# extdata directory to calculate the positions of "corners" on the plot. This cannot#
# be made into a straight up BioGeoBEARS function because it uses C routines #
# from the package APE which do not pass R CMD check for some reason.#
#
########################################################
# SETUP: YOUR TREE FILE AND GEOGRAPHY FILE#
########################################################
# Example files are given below. To run your own data,#
# make the below lines point to your own files, e.g.#
# trfn = "/mydata/frogs/frogBGB/tree.newick"#
# geogfn = "/mydata/frogs/frogBGB/geog.data"#
#
########################################################
# Phylogeny file#
# Notes: #
# 1. Must be binary/bifurcating: no polytomies#
# 2. No negative branchlengths (e.g. BEAST MCC consensus trees sometimes have negative branchlengths)#
# 3. Be careful of very short branches, as BioGeoBEARS will interpret ultrashort branches as direct ancestors#
# 4. You can use non-ultrametric trees, but BioGeoBEARS will interpret any tips significantly below the #
#    top of the tree as fossils!  This is only a good idea if you actually do have fossils in your tree,#
#    as in e.g. Wood, Matzke et al. (2013), Systematic Biology.#
# 5. The default settings of BioGeoBEARS make sense for trees where the branchlengths are in units of #
#    millions of years, and the tree is 1-1000 units tall. If you have a tree with a total height of#
#    e.g. 0.00001, you will need to adjust e.g. the max values of d and e, or (simpler) multiply all#
#    your branchlengths to get them into reasonable units.#
# 6. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
########################################################
# This is the example Newick file for Hawaiian Psychotria#
# (from Ree & Smith 2008)#
# "trfn" = "tree file name"#
trfn = np(paste(addslash(extdata_dir), "Psychotria_5.2.newick", sep=""))#
#
# Look at the raw Newick file:#
moref(trfn)#
#
# Look at your phylogeny (plots to a PDF, which avoids issues with multiple graphics in same window):#
pdffn = "tree.pdf"#
pdf(file=pdffn, height=9, width=9)#
#
tr = read.tree(trfn)#
tr#
plot(tr, cex=0.5)#
title("Example Psychotria phylogeny from Ree & Smith (2008)")#
axisPhylo() # plots timescale#
mtext("Millions of years ago (Ma)", side=1, line=2)#
#
dev.off()#
cmdstr = paste0("open ", pdffn)#
system(cmdstr)#
#
########################################################
# Geography file#
# Notes:#
# 1. This is a PHYLIP-formatted file. This means that in the #
#    first line, #
#    - the 1st number equals the number of rows (species)#
#    - the 2nd number equals the number of columns (number of areas)#
#    - after a tab, put the areas in parentheses, with spaces: (A B C D)#
##
# 1.5. Example first line:#
#    10    4    (A B C D)#
# #
# 2. The second line, and subsequent lines:#
#    speciesA    0110#
#    speciesB    0111#
#    speciesC    0001#
#         ...#
# #
# 2.5a. This means a TAB between the species name and the area 0/1s#
# 2.5b. This also means NO SPACE AND NO TAB between the area 0/1s.#
# #
# 3. See example files at:#
#    http://phylo.wikidot.com/biogeobears#files#
# #
# 4. Make you understand what a PLAIN-TEXT EDITOR is:#
#    http://phylo.wikidot.com/biogeobears#texteditors#
##
# 3. The PHYLIP format is the same format used for C++ LAGRANGE geography files.#
##
# 4. All names in the geography file must match names in the phylogeny file.#
##
# 5. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
##
# 6. Operational taxonomic units (OTUs) should ideally be phylogenetic lineages, #
#    i.e. genetically isolated populations.  These may or may not be identical #
#    with species.  You would NOT want to just use specimens, as each specimen #
#    automatically can only live in 1 area, which will typically favor DEC+J #
#    models.  This is fine if the species/lineages really do live in single areas,#
#    but you wouldn't want to assume this without thinking about it at least. #
#    In summary, you should collapse multiple specimens into species/lineages if #
#    data indicates they are the same genetic population.#
#######################################################
#
# This is the example geography file for Hawaiian Psychotria#
# (from Ree & Smith 2008)#
geogfn = np(paste(addslash(extdata_dir), "Psychotria_geog.data", sep=""))#
#
# Look at the raw geography text file:#
moref(geogfn)#
#
# Look at your geographic range data:#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Maximum range size observed:#
max(rowSums(dfnums_to_numeric(tipranges@df)))#
#
# Set the maximum number of areas any species may occupy; this cannot be larger #
# than the number of areas you set up, but it can be smaller.#
max_range_size = 4#
#
#####################################################
#####################################################
# KEY HINT: The number of states (= number of different possible geographic ranges)#
# depends on (a) the number of areas and (b) max_range_size.#
# If you have more than about 500-600 states, the calculations will get REALLY slow,#
# since the program has to exponentiate a matrix of e.g. 600x600.  Often the computer#
# will just sit there and crunch, and never get through the calculation of the first#
# likelihood.#
# #
# (this is also what is usually happening when LAGRANGE hangs: you have too many states!)#
##
# To check the number of states for a given number of ranges, try:#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=FALSE)#
numstates_from_numareas(numareas=4, maxareas=3, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=2, include_null_range=TRUE)#
#
# Large numbers of areas have problems:#
numstates_from_numareas(numareas=10, maxareas=10, include_null_range=TRUE)#
#
# ...unless you limit the max_range_size:#
numstates_from_numareas(numareas=10, maxareas=2, include_null_range=TRUE)#
#####################################################
#####################################################
#
########################################################
########################################################
# DEC AND DEC+J ANALYSIS#
########################################################
########################################################
# NOTE: The BioGeoBEARS "DEC" model is identical with #
# the Lagrange DEC model, and should return identical#
# ML estimates of parameters, and the same #
# log-likelihoods, for the same datasets.#
##
# Ancestral state probabilities at nodes will be slightly #
# different, since BioGeoBEARS is reporting the #
# ancestral state probabilities under the global ML#
# model, and Lagrange is reporting ancestral state#
# probabilities after re-optimizing the likelihood#
# after fixing the state at each node. These will #
# be similar, but not identical. See Matzke (2014),#
# Systematic Biology, for discussion.#
##
# Also see Matzke (2014) for presentation of the #
# DEC+J model.#
########################################################
########################################################
#
########################################################
########################################################
#
########################################################
# Run DEC#
########################################################
#
# Intitialize a default model (DEC model)#
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
#
# Give BioGeoBEARS the location of the phylogeny Newick file#
BioGeoBEARS_run_object$trfn = trfn#
#
# Give BioGeoBEARS the location of the geography text file#
BioGeoBEARS_run_object$geogfn = geogfn#
#
# Input the maximum range size#
BioGeoBEARS_run_object$max_range_size = max_range_size#
#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
# 1. Here, un-comment ONLY the files you want to use.#
# 2. Also un-comment "BioGeoBEARS_run_object = section_the_tree(...", below.#
# 3. For example files see (a) extdata_dir, #
#  or (b) http://phylo.wikidot.com/biogeobears#files#
#  and BioGeoBEARS Google Group posts for further hints)#
##
# Uncomment files you wish to use in time-stratified analyses:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx();#
# if "GenSA", use Generalized Simulated Annealing, which seems better on high-dimensional#
# problems (5+ parameters), but seems to sometimes fail to optimize on simple problems#
BioGeoBEARS_run_object$num_cores_to_use = 1#
# (use more cores to speed it up; this requires#
# library(parallel) and/or library(snow). The package "parallel" #
# is now default on Macs in R 3.0+, but apparently still #
# has to be typed on some Windows machines. Note: apparently #
# parallel works on Mac command-line R, but not R.app.#
# BioGeoBEARS checks for this and resets to 1#
# core with R.app)#
#
# Sparse matrix exponentiation is an option for huge numbers of ranges/states (600+)#
# I have experimented with sparse matrix exponentiation in EXPOKIT/rexpokit,#
# but the results are imprecise and so I haven't explored it further.#
# In a Bayesian analysis, it might work OK, but the ML point estimates are#
# not identical.#
# Also, I have not implemented all functions to work with force_sparse=TRUE.#
# Volunteers are welcome to work on it!!#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE, fossils_older_than=0.001, cut_fossils=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC model#
# (nothing to do; defaults)#
#
# Look at the BioGeoBEARS_run_object; it's just a list of settings etc.#
BioGeoBEARS_run_object#
#
# This contains the model object#
BioGeoBEARS_run_object$BioGeoBEARS_model_object#
#
# This table contains the parameters of the model #
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table#
#
# Run this to check inputs. Read the error messages if you get them!#
BioGeoBEARS_run_object = fix_BioGeoBEARS_params_minmax(BioGeoBEARS_run_object=BioGeoBEARS_run_object)#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# For a slow analysis, run once, then set runslow=FALSE to just #
# load the saved result.#
runslow = TRUE#
resfn = "Psychotria_DEC_M0_unconstrained_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resDEC = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDEC = res#
    }#
#
########################################################
# Run DEC+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx();#
# if "GenSA", use Generalized Simulated Annealing, which seems better on high-dimensional#
# problems (5+ parameters), but seems to sometimes fail to optimize on simple problems#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE, fossils_older_than=0.001, cut_fossils=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resDEC$outputs@params_table["d","est"]#
estart = resDEC$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# Add j as a free parameter#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
BioGeoBEARS_run_object = fix_BioGeoBEARS_params_minmax(BioGeoBEARS_run_object=BioGeoBEARS_run_object)#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "Psychotria_DEC+J_M0_unconstrained_v1.Rdata"#
runslow = TRUE#
if (runslow)#
    {#
    #sourceall("/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resDECj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDECj = res#
    }#
#
########################################################
# PDF plots#
########################################################
pdffn = "Psychotria_DEC_vs_DEC+J_M0_unconstrained_v1.pdf"#
pdf(file=pdffn, height=9, width=9)#
#
########################################################
# Plot ancestral states - DEC#
########################################################
analysis_titletxt ="BioGeoBEARS DEC on Psychotria M0_unconstrained"#
#
# Setup#
results_object = resDEC#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
########################################################
# Plot ancestral states - DECJ#
########################################################
analysis_titletxt ="BioGeoBEARS DEC+J on Psychotria M0_unconstrained"#
#
# Setup#
results_object = resDECj#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res1 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()  # Turn off PDF#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr) # Plot it#
#
########################################################
########################################################
# DIVALIKE AND DIVALIKE+J ANALYSIS#
########################################################
########################################################
# NOTE: The BioGeoBEARS "DIVALIKE" model is not identical with #
# Ronquist (1997)'s parsimony DIVA. It is a likelihood#
# interpretation of DIVA, constructed by modelling DIVA's#
# processes the way DEC does, but only allowing the #
# processes DIVA allows (widespread vicariance: yes; subset#
# sympatry: no; see Ronquist & Sanmartin 2011, Figure 4).#
##
# DIVALIKE is a likelihood interpretation of parsimony#
# DIVA, and it is "like DIVA" -- similar to, but not#
# identical to, parsimony DIVA.#
##
# I thus now call the model "DIVALIKE", and you should also. ;-)#
########################################################
########################################################
#
########################################################
# Run DIVALIKE#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx();#
# if "GenSA", use Generalized Simulated Annealing, which seems better on high-dimensional#
# problems (5+ parameters), but seems to sometimes fail to optimize on simple problems#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE, fossils_older_than=0.001, cut_fossils=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DIVALIKE model#
# Remove subset-sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "2-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "ysv*1/2"#
#
# Allow classic, widespread vicariance; all events equiprobable#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","init"] = 0.5#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","est"] = 0.5#
#
# No jump dispersal/founder-event speciation#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = 0.01#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = 0.01#
#
BioGeoBEARS_run_object = fix_BioGeoBEARS_params_minmax(BioGeoBEARS_run_object=BioGeoBEARS_run_object)#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
runslow = TRUE#
resfn = "Psychotria_DIVALIKE_M0_unconstrained_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resDIVALIKE = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDIVALIKE = res#
    }#
#
########################################################
# Run DIVALIKE+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx();#
# if "GenSA", use Generalized Simulated Annealing, which seems better on high-dimensional#
# problems (5+ parameters), but seems to sometimes fail to optimize on simple problems#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE, fossils_older_than=0.001, cut_fossils=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DIVALIKE+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resDIVALIKE$outputs@params_table["d","est"]#
estart = resDIVALIKE$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# Remove subset-sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "2-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "ysv*1/2"#
#
# Allow classic, widespread vicariance; all events equiprobable#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","init"] = 0.5#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","est"] = 0.5#
#
# Add jump dispersal/founder-event speciation#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
# Under DIVALIKE+J, the max of "j" should be 2, not 3 (as is default in DEC+J)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","min"] = 0.00001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","max"] = 1.99999#
#
BioGeoBEARS_run_object = fix_BioGeoBEARS_params_minmax(BioGeoBEARS_run_object=BioGeoBEARS_run_object)#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "Psychotria_DIVALIKE+J_M0_unconstrained_v1.Rdata"#
runslow = TRUE#
if (runslow)#
    {#
    #sourceall("/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resDIVALIKEj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDIVALIKEj = res#
    }#
#
pdffn = "Psychotria_DIVALIKE_vs_DIVALIKE+J_M0_unconstrained_v1.pdf"#
pdf(file=pdffn, height=9, width=9)#
#
########################################################
# Plot ancestral states - DIVALIKE#
########################################################
analysis_titletxt ="BioGeoBEARS DIVALIKE on Psychotria M0_unconstrained"#
#
# Setup#
results_object = resDIVALIKE#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
########################################################
# Plot ancestral states - DIVALIKE+J#
########################################################
analysis_titletxt ="BioGeoBEARS DIVALIKE+J on Psychotria M0_unconstrained"#
#
# Setup#
results_object = resDIVALIKEj#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res1 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr)#
#
########################################################
########################################################
# BAYAREALIKE AND BAYAREALIKE+J ANALYSIS#
########################################################
########################################################
# NOTE: As with DIVA, the BioGeoBEARS BayArea-like model is #
# not identical with the full Bayesian model implemented #
# in the "BayArea" program of Landis et al. (2013). #
##
# Instead, this is a simplified likelihood interpretation#
# of the model.  Basically, in BayArea and BioGeoBEARS-BAYAREALIKE, #
# "d" and "e" work like they do in the DEC model of Lagrange #
# (and BioGeoBEARS), and then BayArea's cladogenesis assumption#
# (which is that nothing in particular happens at cladogenesis) is #
# replicated by BioGeoBEARS.#
##
# This leaves out 3 important things that are in BayArea:#
# 1. Distance dependence (you can add this with a distances #
#    matrix + the "x" parameter in BioGeoBEARS, however)#
# 2. A correction for disallowing "e" events that drive#
#    a species extinct (a null geographic range)#
# 3. The neat Bayesian sampling of histories, which allows#
#    analyses on large numbers of areas.#
##
# The main purpose of having a "BAYAREALIKE" model is #
# to test the importance of the cladogenesis model on #
# particular datasets. Does it help or hurt the data #
# likelihood if there is no special cladogenesis process?#
# #
# BAYAREALIKE is a likelihood interpretation of BayArea,#
# and it is "like BayArea" -- similar to, but not#
# identical to, Bayesian BayArea.#
# I thus now call the model "BAYAREALIKE", and you should also. ;-)#
########################################################
########################################################
#
########################################################
# Run BAYAREALIKE#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx();#
# if "GenSA", use Generalized Simulated Annealing, which seems better on high-dimensional#
# problems (5+ parameters), but seems to sometimes fail to optimize on simple problems#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE, fossils_older_than=0.001, cut_fossils=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up BAYAREALIKE model#
# No subset sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
# No vicariance#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","est"] = 0.0#
#
# No jump dispersal/founder-event speciation#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = 0.01#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = 0.01#
#
# Adjust linkage between parameters#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "1-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/1"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "1-j"#
#
# Only sympatric/range-copying (y) events allowed, and with #
# exact copying (both descendants always the same size as the ancestor)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","init"] = 0.9999#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","est"] = 0.9999#
#
# Check the inputs; fixing any initial ("init") values outside min/max#
BioGeoBEARS_run_object = fix_BioGeoBEARS_params_minmax(BioGeoBEARS_run_object=BioGeoBEARS_run_object)#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
runslow = TRUE#
resfn = "Psychotria_BAYAREALIKE_M0_unconstrained_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resBAYAREALIKE = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resBAYAREALIKE = res#
    }#
#
########################################################
# Run BAYAREALIKE+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE, fossils_older_than=0.001, cut_fossils=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up BAYAREALIKE+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resBAYAREALIKE$outputs@params_table["d","est"]#
estart = resBAYAREALIKE$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# No subset sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
# No vicariance#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","est"] = 0.0#
#
# *DO* allow jump dispersal/founder-event speciation (set the starting value close to 0)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
# Under BAYAREALIKE+J, the max of "j" should be 1, not 3 (as is default in DEC+J) or 2 (as in DIVALIKE+J)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","max"] = 0.99999#
#
# Adjust linkage between parameters#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "1-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/1"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "1-j"#
#
# Only sympatric/range-copying (y) events allowed, and with #
# exact copying (both descendants always the same size as the ancestor)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","init"] = 0.9999#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","est"] = 0.9999#
#
# NOTE (NJM, 2014-04): BAYAREALIKE+J seems to crash on some computers, usually Windows #
# machines. I can't replicate this on my Mac machines, but it is almost certainly#
# just some precision under-run issue, when optim/optimx tries some parameter value #
# just below zero.  The "min" and "max" options on each parameter are supposed to#
# prevent this, but apparently optim/optimx sometimes go slightly beyond #
# these limits.  Anyway, if you get a crash, try raising "min" and lowering "max" #
# slightly for each parameter:#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","min"] = 0.0000001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","max"] = 4.9999999#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","min"] = 0.0000001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","max"] = 4.9999999#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","min"] = 0.00001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","max"] = 0.99999#
#
BioGeoBEARS_run_object = fix_BioGeoBEARS_params_minmax(BioGeoBEARS_run_object=BioGeoBEARS_run_object)#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "Psychotria_BAYAREALIKE+J_M0_unconstrained_v1.Rdata"#
runslow = TRUE#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resBAYAREALIKEj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resBAYAREALIKEj = res#
    }#
#
pdffn = "Psychotria_BAYAREALIKE_vs_BAYAREALIKE+J_M0_unconstrained_v1.pdf"#
pdf(file=pdffn, height=9, width=9)#
#
########################################################
# Plot ancestral states - BAYAREALIKE#
########################################################
analysis_titletxt ="BioGeoBEARS BAYAREALIKE on Psychotria M0_unconstrained"#
#
# Setup#
results_object = resBAYAREALIKE#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
########################################################
# Plot ancestral states - BAYAREALIKE+J#
########################################################
analysis_titletxt ="BioGeoBEARS BAYAREALIKE+J on Psychotria M0_unconstrained"#
#
# Setup#
results_object = resBAYAREALIKEj#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res1 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr)#
#
##########################################################################
##########################################################################
##########################################################################
##########################################################################
# #
# CALCULATE SUMMARY STATISTICS TO COMPARE#
# DEC, DEC+J, DIVALIKE, DIVALIKE+J, BAYAREALIKE, BAYAREALIKE+J#
# #
##########################################################################
##########################################################################
##########################################################################
##########################################################################
#
##########################################################################
##########################################################################
# REQUIRED READING:#
##
# Practical advice / notes / basic principles on statistical model #
#    comparison in general, and in BioGeoBEARS:#
# http://phylo.wikidot.com/advice-on-statistical-model-comparison-in-biogeobears#
##########################################################################
##########################################################################
#
# Set up empty tables to hold the statistical results#
restable = NULL#
teststable = NULL#
#
########################################################
# Statistics -- DEC vs. DEC+J#
########################################################
# We have to extract the log-likelihood differently, depending on the #
# version of optim/optimx#
LnL_2 = get_LnL_from_BioGeoBEARS_results_object(resDEC)#
LnL_1 = get_LnL_from_BioGeoBEARS_results_object(resDECj)#
#
numparams1 = 3#
numparams2 = 2#
stats = AICstats_2models(LnL_1, LnL_2, numparams1, numparams2)#
stats#
#
# DEC, null model for Likelihood Ratio Test (LRT)#
res2 = extract_params_from_BioGeoBEARS_results_object(results_object=resDEC, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
# DEC+J, alternative model for Likelihood Ratio Test (LRT)#
res1 = extract_params_from_BioGeoBEARS_results_object(results_object=resDECj, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
#
# The null hypothesis for a Likelihood Ratio Test (LRT) is that two models#
# confer the same likelihood on the data. See: Brian O'Meara's webpage:#
# http://www.brianomeara.info/tutorials/aic#
# ...for an intro to LRT, AIC, and AICc#
#
rbind(res2, res1)#
tmp_tests = conditional_format_table(stats)#
#
restable = rbind(restable, res2, res1)#
teststable = rbind(teststable, tmp_tests)#
#
########################################################
# Statistics -- DIVALIKE vs. DIVALIKE+J#
########################################################
# We have to extract the log-likelihood differently, depending on the #
# version of optim/optimx#
LnL_2 = get_LnL_from_BioGeoBEARS_results_object(resDIVALIKE)#
LnL_1 = get_LnL_from_BioGeoBEARS_results_object(resDIVALIKEj)#
#
numparams1 = 3#
numparams2 = 2#
stats = AICstats_2models(LnL_1, LnL_2, numparams1, numparams2)#
stats#
#
# DIVALIKE, null model for Likelihood Ratio Test (LRT)#
res2 = extract_params_from_BioGeoBEARS_results_object(results_object=resDIVALIKE, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
# DIVALIKE+J, alternative model for Likelihood Ratio Test (LRT)#
res1 = extract_params_from_BioGeoBEARS_results_object(results_object=resDIVALIKEj, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
#
rbind(res2, res1)#
conditional_format_table(stats)#
#
tmp_tests = conditional_format_table(stats)#
#
restable = rbind(restable, res2, res1)#
teststable = rbind(teststable, tmp_tests)#
#
########################################################
# Statistics -- BAYAREALIKE vs. BAYAREALIKE+J#
########################################################
# We have to extract the log-likelihood differently, depending on the #
# version of optim/optimx#
LnL_2 = get_LnL_from_BioGeoBEARS_results_object(resBAYAREALIKE)#
LnL_1 = get_LnL_from_BioGeoBEARS_results_object(resBAYAREALIKEj)#
#
numparams1 = 3#
numparams2 = 2#
stats = AICstats_2models(LnL_1, LnL_2, numparams1, numparams2)#
stats#
#
# BAYAREALIKE, null model for Likelihood Ratio Test (LRT)#
res2 = extract_params_from_BioGeoBEARS_results_object(results_object=resBAYAREALIKE, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
# BAYAREALIKE+J, alternative model for Likelihood Ratio Test (LRT)#
res1 = extract_params_from_BioGeoBEARS_results_object(results_object=resBAYAREALIKEj, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
#
rbind(res2, res1)#
conditional_format_table(stats)#
#
tmp_tests = conditional_format_table(stats)#
#
restable = rbind(restable, res2, res1)#
teststable = rbind(teststable, tmp_tests)#
#
##########################################################################
# ASSEMBLE RESULTS TABLES: DEC, DEC+J, DIVALIKE, DIVALIKE+J, BAYAREALIKE, BAYAREALIKE+J#
##########################################################################
teststable$alt = c("DEC+J", "DIVALIKE+J", "BAYAREALIKE+J")#
teststable$null = c("DEC", "DIVALIKE", "BAYAREALIKE")#
row.names(restable) = c("DEC", "DEC+J", "DIVALIKE", "DIVALIKE+J", "BAYAREALIKE", "BAYAREALIKE+J")#
restable = put_jcol_after_ecol(restable)#
restable#
#
# Look at the results!!#
restable#
teststable#
#
########################################################
# Save the results tables for later -- check for e.g.#
# convergence issues#
########################################################
#
# Loads to "restable"#
save(restable, file="restable_v1.Rdata")#
load(file="restable_v1.Rdata")#
#
# Loads to "teststable"#
save(teststable, file="teststable_v1.Rdata")#
load(file="teststable_v1.Rdata")#
#
# Also save to text files#
write.table(restable, file="restable.txt", quote=FALSE, sep="\t")#
write.table(unlist_df(teststable), file="teststable.txt", quote=FALSE, sep="\t")#
#
########################################################
# Model weights of all six models#
########################################################
restable2 = restable#
#
# With AICs:#
AICtable = calc_AIC_column(LnL_vals=restable$LnL, nparam_vals=restable$numparams)#
restable = cbind(restable, AICtable)#
restable_AIC_rellike = AkaikeWeights_on_summary_table(restable=restable, colname_to_use="AIC")#
restable_AIC_rellike = put_jcol_after_ecol(restable_AIC_rellike)#
restable_AIC_rellike#
#
# With AICcs -- factors in sample size#
samplesize = length(tr$tip.label)#
AICtable = calc_AICc_column(LnL_vals=restable$LnL, nparam_vals=restable$numparams, samplesize=samplesize)#
restable2 = cbind(restable2, AICtable)#
restable_AICc_rellike = AkaikeWeights_on_summary_table(restable=restable2, colname_to_use="AICc")#
restable_AICc_rellike = put_jcol_after_ecol(restable_AICc_rellike)#
restable_AICc_rellike#
#
# Also save to text files#
write.table(restable_AIC_rellike, file="restable_AIC_rellike.txt", quote=FALSE, sep="\t")#
write.table(restable_AICc_rellike, file="restable_AICc_rellike.txt", quote=FALSE, sep="\t")#
#
# Save with nice conditional formatting#
write.table(conditional_format_table(restable_AIC_rellike), file="restable_AIC_rellike_formatted.txt", quote=FALSE, sep="\t")#
write.table(conditional_format_table(restable_AICc_rellike), file="restable_AICc_rellike_formatted.txt", quote=FALSE, sep="\t")
system("open restable_AICc_rellike.txt")
.Platform$GUI != "AQUA"
.Platform$GUI == "AQUA"
# Load the package (after installation, see above).#
library(GenSA)    # GenSA is better than optimx (although somewhat slower)#
library(optimx)    # GenSA is better than optimx (although somewhat slower)#
library(FD)       # for FD::maxent() (make sure this is up-to-date)#
library(snow)     # (if you want to use multicore functionality; some systems/R versions prefer library(parallel), try either)#
library(parallel)#
#
########################################################
# 2018-10-10 update: I have been putting the #
# updates on CRAN/GitHub#
# You should use:#
# rexpokit version 0.26.6 from CRAN#
# cladoRcpp version 0.15 from CRAN#
# BioGeoBEARS version 1.1 from GitHub, install with:#
# library(devtools)#
# devtools::install_github(repo="nmatzke/BioGeoBEARS")#
########################################################
library(rexpokit)#
library(cladoRcpp)#
library(BioGeoBEARS)#
########################################################
# SETUP: YOUR WORKING DIRECTORY#
########################################################
# You will need to set your working directory to match your local system#
#
# Note these very handy functions!#
# Command "setwd(x)" sets your working directory#
# Command "getwd()" gets your working directory and tells you what it is.#
# Command "list.files()" lists the files in your working directory#
# To get help on any command, use "?".  E.g., "?list.files"#
#
# Set your working directory for output files#
# default here is your home directory ("~")#
# Change this as you like#
# wd = slashslash(paste0(addslash(extdata_dir), "/examples/BSM_Psychotria/M3areas_allowed/"))#
# setwd(wd)#
#
wd = "/GitHub/BioGeoBEARS/inst/extdata/examples/Psychotria_M3strat/BSM_to_simmap/"#
setwd(wd)#
#
# Double-check your working directory with getwd()#
getwd()#
#
########################################################
# SETUP: Extension data directory#
########################################################
# When R packages contain extra files, they are stored in the "extdata" directory #
# inside the installed package.#
##
# BioGeoBEARS contains various example files and scripts in its extdata directory.#
# #
# Each computer operating system might install BioGeoBEARS in a different place, #
# depending on your OS and settings. #
# #
# However, you can find the extdata directory like this:#
extdata_dir = np(system.file("extdata", package="BioGeoBEARS"))#
extdata_dir#
list.files(extdata_dir)#
# "system.file" looks in the directory of a specified package (in this case BioGeoBEARS)#
# The function "np" is just a shortcut for normalizePath(), which converts the #
# path to the format appropriate for your system (e.g., Mac/Linux use "/", but #
# Windows uses "\\", if memory serves).#
#
# Even when using your own data files, you should KEEP these commands in your #
# script, since the plot_BioGeoBEARS_results function needs a script from the #
# extdata directory to calculate the positions of "corners" on the plot. This cannot#
# be made into a straight up BioGeoBEARS function because it uses C routines #
# from the package APE which do not pass R CMD check for some reason.#
#
########################################################
# SETUP: YOUR TREE FILE AND GEOGRAPHY FILE#
########################################################
# Example files are given below. To run your own data,#
# make the below lines point to your own files, e.g.#
# trfn = "/mydata/frogs/frogBGB/tree.newick"#
# geogfn = "/mydata/frogs/frogBGB/geog.data"#
#
########################################################
# Phylogeny file#
# Notes: #
# 1. Must be binary/bifurcating: no polytomies#
# 2. No negative branchlengths (e.g. BEAST MCC consensus trees sometimes have negative branchlengths)#
# 3. Be careful of very short branches, as BioGeoBEARS will interpret ultrashort branches as direct ancestors#
# 4. You can use non-ultrametric trees, but BioGeoBEARS will interpret any tips significantly below the #
#    top of the tree as fossils!  This is only a good idea if you actually do have fossils in your tree,#
#    as in e.g. Wood, Matzke et al. (2013), Systematic Biology.#
# 5. The default settings of BioGeoBEARS make sense for trees where the branchlengths are in units of #
#    millions of years, and the tree is 1-1000 units tall. If you have a tree with a total height of#
#    e.g. 0.00001, you will need to adjust e.g. the max values of d and e, or (simpler) multiply all#
#    your branchlengths to get them into reasonable units.#
# 6. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
########################################################
# This is the example Newick file for Hawaiian Psychotria#
# (from Ree & Smith 2008)#
# "trfn" = "tree file name"#
trfn = "tree.newick"#
#
# Look at the raw Newick file:#
moref(trfn)#
pdffn = "tree.pdf"#
pdf(file=pdffn, width=6, height=6)#
#
# Look at your phylogeny:#
tr = read.tree(trfn)#
tr#
plot(tr)#
title("Example tree")#
axisPhylo() # plots timescale#
dev.off()#
#
cmdstr = paste0("open ", pdffn)#
system(cmdstr)#
########################################################
# Geography file#
# Notes:#
# 1. This is a PHYLIP-formatted file. This means that in the #
#    first line, #
#    - the 1st number equals the number of rows (species)#
#    - the 2nd number equals the number of columns (number of areas)#
#    - after a tab, put the areas in parentheses, with spaces: (A B C D)#
##
# 1.5. Example first line:#
#    10    4    (A B C D)#
# #
# 2. The second line, and subsequent lines:#
#    speciesA    0110#
#    speciesB    0111#
#    speciesC    0001#
#         ...#
# #
# 2.5a. This means a TAB between the species name and the area 0/1s#
# 2.5b. This also means NO SPACE AND NO TAB between the area 0/1s.#
# #
# 3. See example files at:#
#    http://phylo.wikidot.com/biogeobears#files#
# #
# 4. Make you understand what a PLAIN-TEXT EDITOR is:#
#    http://phylo.wikidot.com/biogeobears#texteditors#
##
# 3. The PHYLIP format is the same format used for C++ LAGRANGE geography files.#
##
# 4. All names in the geography file must match names in the phylogeny file.#
##
# 5. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
##
# 6. Operational taxonomic units (OTUs) should ideally be phylogenetic lineages, #
#    i.e. genetically isolated populations.  These may or may not be identical #
#    with species.  You would NOT want to just use specimens, as each specimen #
#    automatically can only live in 1 area, which will typically favor DEC+J #
#    models.  This is fine if the species/lineages really do live in single areas,#
#    but you wouldn't want to assume this without thinking about it at least. #
#    In summary, you should collapse multiple specimens into species/lineages if #
#    data indicates they are the same genetic population.#
#######################################################
#
# This is the example geography file for Hawaiian Psychotria#
# (from Ree & Smith 2008)#
geogfn = "geog.data"#
#
# Look at the raw geography text file:#
moref(geogfn)#
#
# Look at your geographic range data:#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Maximum range size observed:#
max(rowSums(dfnums_to_numeric(tipranges@df)))#
#
# Set the maximum number of areas any species may occupy; this cannot be larger #
# than the number of areas you set up, but it can be smaller.#
max_range_size = 4#
#
#####################################################
#####################################################
# KEY HINT: The number of states (= number of different possible geographic ranges)#
# depends on (a) the number of areas and (b) max_range_size.#
# If you have more than about 500-600 states, the calculations will get REALLY slow,#
# since the program has to exponentiate a matrix of e.g. 600x600.  Often the computer#
# will just sit there and crunch, and never get through the calculation of the first#
# likelihood.#
# #
# (this is also what is usually happening when LAGRANGE hangs: you have too many states!)#
##
# To check the number of states for a given number of ranges, try:#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=FALSE)#
numstates_from_numareas(numareas=4, maxareas=3, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=2, include_null_range=TRUE)#
#
# Large numbers of areas have problems:#
numstates_from_numareas(numareas=10, maxareas=10, include_null_range=TRUE)#
#
# ...unless you limit the max_range_size:#
numstates_from_numareas(numareas=10, maxareas=2, include_null_range=TRUE)#
#####################################################
#####################################################
#
########################################################
########################################################
# DEC AND DEC+J ANALYSIS#
########################################################
########################################################
# NOTE: The BioGeoBEARS "DEC" model is identical with #
# the Lagrange DEC model, and should return identical#
# ML estimates of parameters, and the same #
# log-likelihoods, for the same datasets.#
##
# Ancestral state probabilities at nodes will be slightly #
# different, since BioGeoBEARS is reporting the #
# ancestral state probabilities under the global ML#
# model, and Lagrange is reporting ancestral state#
# probabilities after re-optimizing the likelihood#
# after fixing the state at each node. These will #
# be similar, but not identical. See Matzke (2014),#
# Systematic Biology, for discussion.#
##
# Also see Matzke (2014) for presentation of the #
# DEC+J model.#
########################################################
########################################################
#
########################################################
########################################################
#
########################################################
# Run DEC#
########################################################
#
# Intitialize a default model (DEC model)#
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
#
# Give BioGeoBEARS the location of the phylogeny Newick file#
BioGeoBEARS_run_object$trfn = trfn#
#
# Give BioGeoBEARS the location of the geography text file#
BioGeoBEARS_run_object$geogfn = geogfn#
#
# Input the maximum range size#
BioGeoBEARS_run_object$max_range_size = max_range_size#
#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
# 1. Here, un-comment ONLY the files you want to use.#
# 2. Also un-comment "BioGeoBEARS_run_object = section_the_tree(...", below.#
# 3. For example files see (a) extdata_dir, #
#  or (b) http://phylo.wikidot.com/biogeobears#files#
#  and BioGeoBEARS Google Group posts for further hints)#
##
# Uncomment files you wish to use in time-stratified analyses:#
BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
BioGeoBEARS_run_object$dispersal_multipliers_fn = "dispersal_multipliers.txt"#
BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
# (use more cores to speed it up; this requires#
# library(parallel) and/or library(snow). The package "parallel" #
# is now default on Macs in R 3.0+, but apparently still #
# has to be typed on some Windows machines. Note: apparently #
# parallel works on Mac command-line R, but not R.app.#
# BioGeoBEARS checks for this and resets to 1#
# core with R.app)#
#
# Sparse matrix exponentiation is an option for huge numbers of ranges/states (600+)#
# I have experimented with sparse matrix exponentiation in EXPOKIT/rexpokit,#
# but the results are imprecise and so I haven't explored it further.#
# In a Bayesian analysis, it might work OK, but the ML point estimates are#
# not identical.#
# Also, I have not implemented all functions to work with force_sparse=TRUE.#
# Volunteers are welcome to work on it!!#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC model#
# (nothing to do; defaults)#
#
# Look at the BioGeoBEARS_run_object; it's just a list of settings etc.#
BioGeoBEARS_run_object#
#
# This contains the model object#
BioGeoBEARS_run_object$BioGeoBEARS_model_object#
#
# This table contains the parameters of the model #
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table#
#
# Run this to check inputs. Read the error messages if you get them!#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# For a slow analysis, run once, then set runslow=FALSE to just #
# load the saved result.#
runslow = FALSE#
resfn = "Psychotria_DEC_M3areas_allowed_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resDEC = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDEC = res#
    }#
#
########################################################
# Run DEC+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
BioGeoBEARS_run_object$dispersal_multipliers_fn = "dispersal_multipliers.txt"#
BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resDEC$outputs@params_table["d","est"]#
estart = resDEC$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# Add j as a free parameter#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "Psychotria_DEC+J_M3areas_allowed_v1.Rdata"#
runslow = FALSE#
if (runslow)#
    {#
    #sourceall("/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resDECj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDECj = res#
    }#
#
########################################################
# PDF plots#
########################################################
pdffn = "Psychotria_DEC_vs_DEC+J_M3areas_allowed_v1.pdf"#
pdf(pdffn, width=6, height=6)#
#
########################################################
# Plot ancestral states - DEC#
########################################################
analysis_titletxt ="BioGeoBEARS DEC on Psychotria M3areas_allowed_unconstrained"#
#
# Setup#
results_object = resDEC#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
########################################################
# Plot ancestral states - DECJ#
########################################################
analysis_titletxt ="BioGeoBEARS DEC+J on Psychotria M3areas_allowed_unconstrained"#
#
# Setup#
results_object = resDECj#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res1 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()  # Turn off PDF#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr) # Plot it#
#
########################################################
########################################################
# DIVALIKE AND DIVALIKE+J ANALYSIS#
########################################################
########################################################
# NOTE: The BioGeoBEARS "DIVALIKE" model is not identical with #
# Ronquist (1997)'s parsimony DIVA. It is a likelihood#
# interpretation of DIVA, constructed by modelling DIVA's#
# processes the way DEC does, but only allowing the #
# processes DIVA allows (widespread vicariance: yes; subset#
# sympatry: no; see Ronquist & Sanmartin 2011, Figure 4).#
##
# DIVALIKE is a likelihood interpretation of parsimony#
# DIVA, and it is "like DIVA" -- similar to, but not#
# identical to, parsimony DIVA.#
##
# I thus now call the model "DIVALIKE", and you should also. ;-)#
########################################################
########################################################
#
########################################################
# Run DIVALIKE#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
BioGeoBEARS_run_object$dispersal_multipliers_fn = "dispersal_multipliers.txt"#
BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DIVALIKE model#
# Remove subset-sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "2-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "ysv*1/2"#
#
# Allow classic, widespread vicariance; all events equiprobable#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","init"] = 0.5#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","est"] = 0.5#
#
# No jump dispersal/founder-event speciation#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = 0.01#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = 0.01#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
runslow = FALSE#
resfn = "Psychotria_DIVALIKE_M3areas_allowed_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resDIVALIKE = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDIVALIKE = res#
    }#
#
########################################################
# Run DIVALIKE+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
BioGeoBEARS_run_object$dispersal_multipliers_fn = "dispersal_multipliers.txt"#
BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DIVALIKE+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resDIVALIKE$outputs@params_table["d","est"]#
estart = resDIVALIKE$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# Remove subset-sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "2-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "ysv*1/2"#
#
# Allow classic, widespread vicariance; all events equiprobable#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","init"] = 0.5#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","est"] = 0.5#
#
# Add jump dispersal/founder-event speciation#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
# Under DIVALIKE+J, the max of "j" should be 2, not 3 (as is default in DEC+J)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","min"] = 0.00001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","max"] = 1.99999#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "Psychotria_DIVALIKE+J_M3areas_allowed_v1.Rdata"#
runslow = FALSE#
if (runslow)#
    {#
    #sourceall("/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resDIVALIKEj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDIVALIKEj = res#
    }#
#
pdffn = "Psychotria_DIVALIKE_vs_DIVALIKE+J_M3areas_allowed_v1.pdf"#
pdf(pdffn, width=6, height=6)#
#
########################################################
# Plot ancestral states - DIVALIKE#
########################################################
analysis_titletxt ="BioGeoBEARS DIVALIKE on Psychotria M3areas_allowed_unconstrained"#
#
# Setup#
results_object = resDIVALIKE#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
########################################################
# Plot ancestral states - DIVALIKE+J#
########################################################
analysis_titletxt ="BioGeoBEARS DIVALIKE+J on Psychotria M3areas_allowed_unconstrained"#
#
# Setup#
results_object = resDIVALIKEj#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res1 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr)#
#
########################################################
########################################################
# BAYAREALIKE AND BAYAREALIKE+J ANALYSIS#
########################################################
########################################################
# NOTE: As with DIVA, the BioGeoBEARS BayArea-like model is #
# not identical with the full Bayesian model implemented #
# in the "BayArea" program of Landis et al. (2013). #
##
# Instead, this is a simplified likelihood interpretation#
# of the model.  Basically, in BayArea and BioGeoBEARS-BAYAREALIKE, #
# "d" and "e" work like they do in the DEC model of Lagrange #
# (and BioGeoBEARS), and then BayArea's cladogenesis assumption#
# (which is that nothing in particular happens at cladogenesis) is #
# replicated by BioGeoBEARS.#
##
# This leaves out 3 important things that are in BayArea:#
# 1. Distance dependence (you can add this with a distances #
#    matrix + the "x" parameter in BioGeoBEARS, however)#
# 2. A correction for disallowing "e" events that drive#
#    a species extinct (a null geographic range)#
# 3. The neat Bayesian sampling of histories, which allows#
#    analyses on large numbers of areas.#
##
# The main purpose of having a "BAYAREALIKE" model is #
# to test the importance of the cladogenesis model on #
# particular datasets. Does it help or hurt the data #
# likelihood if there is no special cladogenesis process?#
# #
# BAYAREALIKE is a likelihood interpretation of BayArea,#
# and it is "like BayArea" -- similar to, but not#
# identical to, Bayesian BayArea.#
# I thus now call the model "BAYAREALIKE", and you should also. ;-)#
########################################################
########################################################
#
########################################################
# Run BAYAREALIKE#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
BioGeoBEARS_run_object$dispersal_multipliers_fn = "dispersal_multipliers.txt"#
BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up BAYAREALIKE model#
# No subset sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
# No vicariance#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","est"] = 0.0#
#
# No jump dispersal/founder-event speciation#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = 0.01#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = 0.01#
#
# Adjust linkage between parameters#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "1-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/1"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "1-j"#
#
# Only sympatric/range-copying (y) events allowed, and with #
# exact copying (both descendants always the same size as the ancestor)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","init"] = 0.9999#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","est"] = 0.9999#
#
# Check the inputs#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
runslow = FALSE#
resfn = "Psychotria_BAYAREALIKE_M3areas_allowed_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resBAYAREALIKE = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resBAYAREALIKE = res#
    }#
#
########################################################
# Run BAYAREALIKE+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
BioGeoBEARS_run_object$dispersal_multipliers_fn = "dispersal_multipliers.txt"#
BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up BAYAREALIKE+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resBAYAREALIKE$outputs@params_table["d","est"]#
estart = resBAYAREALIKE$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# No subset sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
# No vicariance#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","est"] = 0.0#
#
# *DO* allow jump dispersal/founder-event speciation (set the starting value close to 0)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
# Under BAYAREALIKE+J, the max of "j" should be 1, not 3 (as is default in DEC+J) or 2 (as in DIVALIKE+J)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","max"] = 0.99999#
#
# Adjust linkage between parameters#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "1-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/1"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "1-j"#
#
# Only sympatric/range-copying (y) events allowed, and with #
# exact copying (both descendants always the same size as the ancestor)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","init"] = 0.9999#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","est"] = 0.9999#
#
# NOTE (NJM, 2014-04): BAYAREALIKE+J seems to crash on some computers, usually Windows #
# machines. I can't replicate this on my Mac machines, but it is almost certainly#
# just some precision under-run issue, when optim/optimx tries some parameter value #
# just below zero.  The "min" and "max" options on each parameter are supposed to#
# prevent this, but apparently optim/optimx sometimes go slightly beyond #
# these limits.  Anyway, if you get a crash, try raising "min" and lowering "max" #
# slightly for each parameter:#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","min"] = 0.0000001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","max"] = 4.9999999#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","min"] = 0.0000001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","max"] = 4.9999999#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","min"] = 0.00001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","max"] = 0.99999#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "Psychotria_BAYAREALIKE+J_M3areas_allowed_v1.Rdata"#
runslow = FALSE#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resBAYAREALIKEj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resBAYAREALIKEj = res#
    }#
#
pdffn = "Psychotria_BAYAREALIKE_vs_BAYAREALIKE+J_M3areas_allowed_v1.pdf"#
pdf(pdffn, width=6, height=6)#
#
########################################################
# Plot ancestral states - BAYAREALIKE#
########################################################
analysis_titletxt ="BioGeoBEARS BAYAREALIKE on Psychotria M3areas_allowed_unconstrained"#
#
# Setup#
results_object = resBAYAREALIKE#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
########################################################
# Plot ancestral states - BAYAREALIKE+J#
########################################################
analysis_titletxt ="BioGeoBEARS BAYAREALIKE+J on Psychotria M3areas_allowed_unconstrained"#
#
# Setup#
results_object = resBAYAREALIKEj#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res1 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr)#
#
##########################################################################
##########################################################################
##########################################################################
##########################################################################
# #
# CALCULATE SUMMARY STATISTICS TO COMPARE#
# DEC, DEC+J, DIVALIKE, DIVALIKE+J, BAYAREALIKE, BAYAREALIKE+J#
# #
##########################################################################
##########################################################################
##########################################################################
##########################################################################
#
##########################################################################
##########################################################################
# REQUIRED READING:#
##
# Practical advice / notes / basic principles on statistical model #
#    comparison in general, and in BioGeoBEARS:#
# http://phylo.wikidot.com/advice-on-statistical-model-comparison-in-biogeobears#
##########################################################################
##########################################################################
#
# Set up empty tables to hold the statistical results#
restable = NULL#
teststable = NULL#
#
########################################################
# Statistics -- DEC vs. DEC+J#
########################################################
# We have to extract the log-likelihood differently, depending on the #
# version of optim/optimx#
LnL_2 = get_LnL_from_BioGeoBEARS_results_object(resDEC)#
LnL_1 = get_LnL_from_BioGeoBEARS_results_object(resDECj)#
#
numparams1 = 3#
numparams2 = 2#
stats = AICstats_2models(LnL_1, LnL_2, numparams1, numparams2)#
stats#
#
# DEC, null model for Likelihood Ratio Test (LRT)#
res2 = extract_params_from_BioGeoBEARS_results_object(results_object=resDEC, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
# DEC+J, alternative model for Likelihood Ratio Test (LRT)#
res1 = extract_params_from_BioGeoBEARS_results_object(results_object=resDECj, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
#
# The null hypothesis for a Likelihood Ratio Test (LRT) is that two models#
# confer the same likelihood on the data. See: Brian O'Meara's webpage:#
# http://www.brianomeara.info/tutorials/aic#
# ...for an intro to LRT, AIC, and AICc#
#
rbind(res2, res1)#
tmp_tests = conditional_format_table(stats)#
#
restable = rbind(restable, res2, res1)#
teststable = rbind(teststable, tmp_tests)#
#
########################################################
# Statistics -- DIVALIKE vs. DIVALIKE+J#
########################################################
# We have to extract the log-likelihood differently, depending on the #
# version of optim/optimx#
LnL_2 = get_LnL_from_BioGeoBEARS_results_object(resDIVALIKE)#
LnL_1 = get_LnL_from_BioGeoBEARS_results_object(resDIVALIKEj)#
#
numparams1 = 3#
numparams2 = 2#
stats = AICstats_2models(LnL_1, LnL_2, numparams1, numparams2)#
stats#
#
# DIVALIKE, null model for Likelihood Ratio Test (LRT)#
res2 = extract_params_from_BioGeoBEARS_results_object(results_object=resDIVALIKE, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
# DIVALIKE+J, alternative model for Likelihood Ratio Test (LRT)#
res1 = extract_params_from_BioGeoBEARS_results_object(results_object=resDIVALIKEj, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
#
rbind(res2, res1)#
conditional_format_table(stats)#
#
tmp_tests = conditional_format_table(stats)#
#
restable = rbind(restable, res2, res1)#
teststable = rbind(teststable, tmp_tests)#
#
########################################################
# Statistics -- BAYAREALIKE vs. BAYAREALIKE+J#
########################################################
# We have to extract the log-likelihood differently, depending on the #
# version of optim/optimx#
LnL_2 = get_LnL_from_BioGeoBEARS_results_object(resBAYAREALIKE)#
LnL_1 = get_LnL_from_BioGeoBEARS_results_object(resBAYAREALIKEj)#
#
numparams1 = 3#
numparams2 = 2#
stats = AICstats_2models(LnL_1, LnL_2, numparams1, numparams2)#
stats#
#
# BAYAREALIKE, null model for Likelihood Ratio Test (LRT)#
res2 = extract_params_from_BioGeoBEARS_results_object(results_object=resBAYAREALIKE, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
# BAYAREALIKE+J, alternative model for Likelihood Ratio Test (LRT)#
res1 = extract_params_from_BioGeoBEARS_results_object(results_object=resBAYAREALIKEj, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
#
rbind(res2, res1)#
conditional_format_table(stats)#
#
tmp_tests = conditional_format_table(stats)#
#
restable = rbind(restable, res2, res1)#
teststable = rbind(teststable, tmp_tests)#
#
##########################################################################
# ASSEMBLE RESULTS TABLES: DEC, DEC+J, DIVALIKE, DIVALIKE+J, BAYAREALIKE, BAYAREALIKE+J#
##########################################################################
teststable$alt = c("DEC+J", "DIVALIKE+J", "BAYAREALIKE+J")#
teststable$null = c("DEC", "DIVALIKE", "BAYAREALIKE")#
row.names(restable) = c("DEC", "DEC+J", "DIVALIKE", "DIVALIKE+J", "BAYAREALIKE", "BAYAREALIKE+J")#
restable = put_jcol_after_ecol(restable)#
restable#
#
# Look at the results!!#
restable#
teststable#
#
########################################################
# Save the results tables for later -- check for e.g.#
# convergence issues#
########################################################
#
# Loads to "restable"#
save(restable, file="restable_v1.Rdata")#
load(file="restable_v1.Rdata")#
#
# Loads to "teststable"#
save(teststable, file="teststable_v1.Rdata")#
load(file="teststable_v1.Rdata")#
#
# Also save to text files#
write.table(restable, file="restable.txt", quote=FALSE, sep="\t")#
write.table(unlist_df(teststable), file="teststable.txt", quote=FALSE, sep="\t")#
#
########################################################
# Model weights of all six models#
########################################################
restable2 = restable#
#
# With AICs:#
AICtable = calc_AIC_column(LnL_vals=restable$LnL, nparam_vals=restable$numparams)#
restable = cbind(restable, AICtable)#
restable_AIC_rellike = AkaikeWeights_on_summary_table(restable=restable, colname_to_use="AIC")#
restable_AIC_rellike = put_jcol_after_ecol(restable_AIC_rellike)#
restable_AIC_rellike#
#
# With AICcs -- factors in sample size#
# samplesize = length(tr$tip.label)#
# AICtable = calc_AICc_column(LnL_vals=restable$LnL, nparam_vals=restable$numparams, samplesize=samplesize)#
# restable2 = cbind(restable2, AICtable)#
# restable_AICc_rellike = AkaikeWeights_on_summary_table(restable=restable2, colname_to_use="AICc")#
# restable_AICc_rellike = put_jcol_after_ecol(restable_AICc_rellike)#
# restable_AICc_rellike#
#
# Also save to text files#
write.table(restable_AIC_rellike, file="restable_AIC_rellike.txt", quote=FALSE, sep="\t")#
#write.table(restable_AICc_rellike, file="restable_AICc_rellike.txt", quote=FALSE, sep="\t")#
#
# Save with nice conditional formatting#
write.table(conditional_format_table(restable_AIC_rellike), file="restable_AIC_rellike_formatted.txt", quote=FALSE, sep="\t")#
#write.table(conditional_format_table(restable_AICc_rellike), file="restable_AICc_rellike_formatted.txt", quote=FALSE, sep="\t")#
#source('/GitHub/BioGeoBEARS/R/BioGeoBEARS_stochastic_mapping_v1.R', chdir = TRUE)#
library(MultinomialCI)#
#
############################################
# Pick your model name:#
############################################
model_name = "DEC"#
res = resDEC#
# model_name = "DEC"#
# res = resDEC#
#
########################################################
# Plot ancestral states - DEC#
########################################################
pdffn = paste0("Psychotria_", model_name, "_v1.pdf")#
pdf(pdffn, width=6, height=6)#
#
analysis_titletxt = paste0(model_name, " on Psychotria")#
#
# Setup#
results_object = res#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()  # Turn off PDF#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr) # Plot it#
#
########################################################
# Stochastic mapping on DEC M3b stratified with islands coming up#
########################################################
clado_events_tables = NULL#
ana_events_tables = NULL#
lnum = 0#
#
########################################################
# Get the inputs for Biogeographical Stochastic Mapping#
# Note: this can be slow for large state spaces and trees, since #
# the independent likelihoods for each branch are being pre-calculated#
# E.g., for 10 areas, this requires calculation of a 1024x1024 matrix#
# for each branch.  On a tree with ~800 tips and thus ~1600 branches, this was about 1.6 gigs#
# for storage of "BSM_inputs_file.Rdata".#
# Update: 2015-09-23 -- now, if you used multicore functionality for the ML analysis,#
# the same settings will be used for get_inputs_for_stochastic_mapping().#
########################################################
BSM_inputs_fn = "BSM_inputs_file.Rdata"#
BSMinputs_runslow = FALSE#
if (BSMinputs_runslow == TRUE)#
    {#
    stochastic_mapping_inputs_list = get_inputs_for_stochastic_mapping(res=res)#
    save(stochastic_mapping_inputs_list, file=BSM_inputs_fn)#
    } else {#
    # Loads to "stochastic_mapping_inputs_list"#
    load(BSM_inputs_fn)#
    } # END if (runInputsSlow)#
#
# Check inputs (doesn't work the same on unconstr)#
names(stochastic_mapping_inputs_list)#
stochastic_mapping_inputs_list$phy2#
stochastic_mapping_inputs_list$COO_weights_columnar#
stochastic_mapping_inputs_list$unconstr#
set.seed(seed=as.numeric(54321))#
#
BSM_runslow = TRUE#
if (BSM_runslow == TRUE)#
    {#
    # Saves to: RES_clado_events_tables.Rdata#
    # Saves to: RES_ana_events_tables.Rdata#
    BSM_output = runBSM(res, stochastic_mapping_inputs_list=stochastic_mapping_inputs_list, maxnum_maps_to_try=100, nummaps_goal=50, maxtries_per_branch=40000, save_after_every_try=TRUE, savedir=getwd(), seedval=12345, wait_before_save=0.01, master_nodenum_toPrint=0)#
#
    RES_clado_events_tables = BSM_output$RES_clado_events_tables#
    RES_ana_events_tables = BSM_output$RES_ana_events_tables#
    } else {#
    # Load previously saved...#
#
    # Loads to: RES_clado_events_tables#
    load(file="RES_clado_events_tables.Rdata")#
    # Loads to: RES_ana_events_tables#
    load(file="RES_ana_events_tables.Rdata")#
    BSM_output = NULL#
    BSM_output$RES_clado_events_tables = RES_clado_events_tables#
    BSM_output$RES_ana_events_tables = RES_ana_events_tables#
    } # END if (runBSMslow == TRUE)#
#
# Extract BSM output#
clado_events_tables = BSM_output$RES_clado_events_tables#
ana_events_tables = BSM_output$RES_ana_events_tables#
head(clado_events_tables[[1]])#
head(ana_events_tables[[1]])#
length(clado_events_tables)#
length(ana_events_tables)#
#
include_null_range = TRUE#
areanames = names(tipranges@df)#
areas = areanames#
max_range_size = 4#
#
# Note: If you did something to change the states_list from the default given the number of areas, you would#
# have to manually make that change here as well! (e.g., areas_allowed matrix, or manual reduction of the states_list)#
states_list_0based = rcpp_areas_list_to_states_list(areas=areas, maxareas=max_range_size, include_null_range=include_null_range)#
#
colors_list_for_states = get_colors_for_states_list_0based(areanames=areanames, states_list_0based=states_list_0based, max_range_size=max_range_size, plot_null_range=TRUE)#
#
# For BSMs, replace white with seashell white#
colors_list_for_states[colors_list_for_states == "#FFFFFF"] = "#FFF5EE"#
#############################################
# Setup for painting a single stochastic map#
#############################################
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
stratified = TRUE#
clado_events_table = clado_events_tables[[1]]#
ana_events_table = ana_events_tables[[1]]#
#
# cols_to_get = names(clado_events_table[,-ncol(clado_events_table)])#
# colnums = match(cols_to_get, names(ana_events_table))#
# ana_events_table_cols_to_add = ana_events_table[,colnums]#
# anagenetic_events_txt_below_node = rep("none", nrow(ana_events_table_cols_to_add))#
# ana_events_table_cols_to_add = cbind(ana_events_table_cols_to_add, anagenetic_events_txt_below_node)#
# rows_to_get_TF = ana_events_table_cols_to_add$node <= length(tr$tip.label)#
# master_table_cladogenetic_events = rbind(ana_events_table_cols_to_add[rows_to_get_TF,], clado_events_table)#
#
#############################################
# Open a PDF#
#############################################
pdffn = paste0(model_name, "_single_stochastic_map_n1.pdf")#
pdf(file=pdffn, width=6, height=6)#
#
# Convert the BSM into a modified res object#
master_table_cladogenetic_events = clado_events_tables[[1]]#
resmod = stochastic_map_states_into_res(res=res, master_table_cladogenetic_events=master_table_cladogenetic_events, stratified=stratified)#
#
plot_BioGeoBEARS_results(results_object=resmod, analysis_titletxt="Stochastic map", addl_params=list("j"), label.offset=0.5, plotwhat="text", cornercoords_loc=scriptdir, root.edge=TRUE, colors_list_for_states=colors_list_for_states, skiptree=FALSE, show.tip.label=TRUE)#
#
# Paint on the branch states#
paint_stochastic_map_branches(res=resmod, master_table_cladogenetic_events=master_table_cladogenetic_events, colors_list_for_states=colors_list_for_states, lwd=5, lty=par("lty"), root.edge=TRUE, stratified=stratified)#
#
plot_BioGeoBEARS_results(results_object=resmod, analysis_titletxt="Stochastic map", addl_params=list("j"), plotwhat="text", cornercoords_loc=scriptdir, root.edge=TRUE, colors_list_for_states=colors_list_for_states, skiptree=TRUE, show.tip.label=TRUE)#
#
#############################################
# Close PDF#
#############################################
dev.off()#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr)#
#
########################################################
# Plot all 50 stochastic maps to PDF#
########################################################
# Setup#
include_null_range = include_null_range#
areanames = areanames#
areas = areanames#
max_range_size = max_range_size#
states_list_0based = rcpp_areas_list_to_states_list(areas=areas, maxareas=max_range_size, include_null_range=include_null_range)#
colors_list_for_states = get_colors_for_states_list_0based(areanames=areanames, states_list_0based=states_list_0based, max_range_size=max_range_size, plot_null_range=TRUE)#
# For BSMs, replace white with seashell white#
colors_list_for_states[colors_list_for_states == "#FFFFFF"] = "#FFF5EE"#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
stratified = stratified#
#
# Loop through the maps and plot to PDF#
pdffn = paste0(model_name, "_", length(clado_events_tables), "BSMs_v1.pdf")#
pdf(file=pdffn, width=6, height=6)#
#
nummaps_goal = 50#
for (i in 1:nummaps_goal)#
    {#
    clado_events_table = clado_events_tables[[i]]#
    analysis_titletxt = paste0(model_name, " - Stochastic Map #", i, "/", nummaps_goal)#
    plot_BSM(results_object=res, clado_events_table=clado_events_table, stratified=stratified, analysis_titletxt=analysis_titletxt, addl_params=list("j"), label.offset=0.5, plotwhat="text", cornercoords_loc=scriptdir, root.edge=TRUE, colors_list_for_states=colors_list_for_states, show.tip.label=TRUE, include_null_range=include_null_range)#
    } # END for (i in 1:nummaps_goal)#
#
dev.off()#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr)#
#
########################################################
# Summarize stochastic map tables#
########################################################
length(clado_events_tables)#
length(ana_events_tables)#
#
head(clado_events_tables[[1]][,-20])#
tail(clado_events_tables[[1]][,-20])#
#
head(ana_events_tables[[1]])#
tail(ana_events_tables[[1]])#
#
areanames = names(tipranges@df)#
actual_names = areanames#
actual_names#
#
# Get the dmat and times (if any)#
dmat_times = get_dmat_times_from_res(res=res, numstates=NULL)#
dmat_times#
#
# Extract BSM output#
clado_events_tables = BSM_output$RES_clado_events_tables#
ana_events_tables = BSM_output$RES_ana_events_tables#
#
# Simulate the source areas#
BSMs_w_sourceAreas = simulate_source_areas_ana_clado(res, clado_events_tables, ana_events_tables, areanames)#
clado_events_tables = BSMs_w_sourceAreas$clado_events_tables#
ana_events_tables = BSMs_w_sourceAreas$ana_events_tables#
#
# Count all anagenetic and cladogenetic events#
counts_list = count_ana_clado_events(clado_events_tables, ana_events_tables, areanames, actual_names)#
#
summary_counts_BSMs = counts_list$summary_counts_BSMs#
print(conditional_format_table(summary_counts_BSMs))#
#
# Histogram of event counts#
hist_event_counts(counts_list, pdffn=paste0(model_name, "_histograms_of_event_counts.pdf"))#
#
########################################################
# Print counts to files#
########################################################
tmpnames = names(counts_list)#
cat("\n\nWriting tables* of counts to tab-delimited text files:\n(* = Tables have dimension=2 (rows and columns). Cubes (dimension 3) and lists (dimension 1) will not be printed to text files.) \n\n")#
for (i in 1:length(tmpnames))#
    {#
    cmdtxt = paste0("item = counts_list$", tmpnames[i])#
    eval(parse(text=cmdtxt))#
#
    # Skip cubes#
    if (length(dim(item)) != 2)#
        {#
        next()#
        }#
#
    outfn = paste0(tmpnames[i], ".txt")#
    if (length(item) == 0)#
        {#
        cat(outfn, " -- NOT written, *NO* events recorded of this type", sep="")#
        cat("\n")#
        } else {#
        cat(outfn)#
        cat("\n")#
        write.table(conditional_format_table(item), file=outfn, quote=FALSE, sep="\t", col.names=TRUE, row.names=TRUE)#
        } # END if (length(item) == 0)#
    } # END for (i in 1:length(tmpnames))#
cat("...done.\n")#
#
########################################################
# Check that ML ancestral state/range probabilities and#
# the mean of the BSMs approximately line up#
########################################################
library(MultinomialCI)    # For 95% CIs on BSM counts#
check_ML_vs_BSM(res, clado_events_tables, model_name, tr=NULL, plot_each_node=FALSE, linreg_plot=TRUE, MultinomialCI=TRUE)#
########################################################
# Convert BioGeoBEARS BSM output to phytools#
########################################################
#
library(phytools)#
Q = matrix(c(-3,1,1,1,1,-3,1,1,1,1,-3,1,1,1,1,-3),4,4)#
rownames(Q) = letters[1:4]#
colnames(Q) = letters[1:4]#
Q#
#
set.seed(seed=54321)#
simdata = sim.history(tree=tr, Q=Q, nsim=1)#
tipdata = simdata$states#
tipdata#
#
set.seed(seed=54321)#
tr2 = make.simmap(tree=tr, x=tipdata, model="ER")#
tr2#
tr2$mapped.edge#
#
set.seed(seed=54321)#
tr2 = make.simmap(tree=tr, x=sort(tipdata), model="ER")#
tr2#
tr2$mapped.edge#
#
# Same!#
# Plot to PDF#
pdffn = "phytools_simmap.pdf"#
pdf(file=pdffn, width=6, height=6)#
#
plotSimmap(tr2,lwd=3)#
#
dev.off()#
cmdstr = paste0("open ", pdffn)#
system(cmdstr)#
########################################################
# Get the ranges_list (useful for colors)#
########################################################
returned_mats = get_Qmat_COOmat_from_BioGeoBEARS_run_object(BioGeoBEARS_run_object=resDEC$inputs)#
ranges_list = returned_mats$ranges_list#
########################################################
# Convert a time-stratified BSM to a phytools BSM#
########################################################
#
res = resDEC#
clado_events_table = clado_events_tables[[1]]#
ana_events_table = ana_events_tables[[1]]#
#
tr_wSimmap = BSM_to_phytools_SM(res=resDEC, clado_events_table=clado_events_tables[[6]], ana_events_table=ana_events_tables[[6]])#
summary(tr_wSimmap)#
print(tr_wSimmap)#
countSimmap(tr_wSimmap)
# Load the package (after installation, see above).#
library(GenSA)    # GenSA is better than optimx (although somewhat slower)#
library(optimx)    # GenSA is better than optimx (although somewhat slower)#
library(FD)       # for FD::maxent() (make sure this is up-to-date)#
library(snow)     # (if you want to use multicore functionality; some systems/R versions prefer library(parallel), try either)#
library(parallel)#
#
########################################################
# 2018-10-10 update: I have been putting the #
# updates on CRAN/GitHub#
# You should use:#
# rexpokit version 0.26.6 from CRAN#
# cladoRcpp version 0.15 from CRAN#
# BioGeoBEARS version 1.1 from GitHub, install with:#
# library(devtools)#
# devtools::install_github(repo="nmatzke/BioGeoBEARS")#
########################################################
library(rexpokit)#
library(cladoRcpp)#
library(BioGeoBEARS)#
########################################################
# SETUP: YOUR WORKING DIRECTORY#
########################################################
# You will need to set your working directory to match your local system#
#
# Note these very handy functions!#
# Command "setwd(x)" sets your working directory#
# Command "getwd()" gets your working directory and tells you what it is.#
# Command "list.files()" lists the files in your working directory#
# To get help on any command, use "?".  E.g., "?list.files"#
#
# Set your working directory for output files#
# default here is your home directory ("~")#
# Change this as you like#
# wd = slashslash(paste0(addslash(extdata_dir), "/examples/BSM_Psychotria/M3areas_allowed/"))#
# setwd(wd)#
#
wd = "~/GitHub/BioGeoBEARS/inst/extdata/examples/Psychotria_M3strat/BSM_to_simmap/"#
setwd(wd)#
#
# Double-check your working directory with getwd()#
getwd()#
#
########################################################
# SETUP: Extension data directory#
########################################################
# When R packages contain extra files, they are stored in the "extdata" directory #
# inside the installed package.#
##
# BioGeoBEARS contains various example files and scripts in its extdata directory.#
# #
# Each computer operating system might install BioGeoBEARS in a different place, #
# depending on your OS and settings. #
# #
# However, you can find the extdata directory like this:#
extdata_dir = np(system.file("extdata", package="BioGeoBEARS"))#
extdata_dir#
list.files(extdata_dir)#
# "system.file" looks in the directory of a specified package (in this case BioGeoBEARS)#
# The function "np" is just a shortcut for normalizePath(), which converts the #
# path to the format appropriate for your system (e.g., Mac/Linux use "/", but #
# Windows uses "\\", if memory serves).#
#
# Even when using your own data files, you should KEEP these commands in your #
# script, since the plot_BioGeoBEARS_results function needs a script from the #
# extdata directory to calculate the positions of "corners" on the plot. This cannot#
# be made into a straight up BioGeoBEARS function because it uses C routines #
# from the package APE which do not pass R CMD check for some reason.#
#
########################################################
# SETUP: YOUR TREE FILE AND GEOGRAPHY FILE#
########################################################
# Example files are given below. To run your own data,#
# make the below lines point to your own files, e.g.#
# trfn = "/mydata/frogs/frogBGB/tree.newick"#
# geogfn = "/mydata/frogs/frogBGB/geog.data"#
#
########################################################
# Phylogeny file#
# Notes: #
# 1. Must be binary/bifurcating: no polytomies#
# 2. No negative branchlengths (e.g. BEAST MCC consensus trees sometimes have negative branchlengths)#
# 3. Be careful of very short branches, as BioGeoBEARS will interpret ultrashort branches as direct ancestors#
# 4. You can use non-ultrametric trees, but BioGeoBEARS will interpret any tips significantly below the #
#    top of the tree as fossils!  This is only a good idea if you actually do have fossils in your tree,#
#    as in e.g. Wood, Matzke et al. (2013), Systematic Biology.#
# 5. The default settings of BioGeoBEARS make sense for trees where the branchlengths are in units of #
#    millions of years, and the tree is 1-1000 units tall. If you have a tree with a total height of#
#    e.g. 0.00001, you will need to adjust e.g. the max values of d and e, or (simpler) multiply all#
#    your branchlengths to get them into reasonable units.#
# 6. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
########################################################
# This is the example Newick file for Hawaiian Psychotria#
# (from Ree & Smith 2008)#
# "trfn" = "tree file name"#
trfn = "tree.newick"#
#
# Look at the raw Newick file:#
moref(trfn)#
pdffn = "tree.pdf"#
pdf(file=pdffn, width=6, height=6)#
#
# Look at your phylogeny:#
tr = read.tree(trfn)#
tr#
plot(tr)#
title("Example tree")#
axisPhylo() # plots timescale#
dev.off()#
#
cmdstr = paste0("open ", pdffn)#
system(cmdstr)#
########################################################
# Geography file#
# Notes:#
# 1. This is a PHYLIP-formatted file. This means that in the #
#    first line, #
#    - the 1st number equals the number of rows (species)#
#    - the 2nd number equals the number of columns (number of areas)#
#    - after a tab, put the areas in parentheses, with spaces: (A B C D)#
##
# 1.5. Example first line:#
#    10    4    (A B C D)#
# #
# 2. The second line, and subsequent lines:#
#    speciesA    0110#
#    speciesB    0111#
#    speciesC    0001#
#         ...#
# #
# 2.5a. This means a TAB between the species name and the area 0/1s#
# 2.5b. This also means NO SPACE AND NO TAB between the area 0/1s.#
# #
# 3. See example files at:#
#    http://phylo.wikidot.com/biogeobears#files#
# #
# 4. Make you understand what a PLAIN-TEXT EDITOR is:#
#    http://phylo.wikidot.com/biogeobears#texteditors#
##
# 3. The PHYLIP format is the same format used for C++ LAGRANGE geography files.#
##
# 4. All names in the geography file must match names in the phylogeny file.#
##
# 5. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
##
# 6. Operational taxonomic units (OTUs) should ideally be phylogenetic lineages, #
#    i.e. genetically isolated populations.  These may or may not be identical #
#    with species.  You would NOT want to just use specimens, as each specimen #
#    automatically can only live in 1 area, which will typically favor DEC+J #
#    models.  This is fine if the species/lineages really do live in single areas,#
#    but you wouldn't want to assume this without thinking about it at least. #
#    In summary, you should collapse multiple specimens into species/lineages if #
#    data indicates they are the same genetic population.#
#######################################################
#
# This is the example geography file for Hawaiian Psychotria#
# (from Ree & Smith 2008)#
geogfn = "geog.data"#
#
# Look at the raw geography text file:#
moref(geogfn)#
#
# Look at your geographic range data:#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Maximum range size observed:#
max(rowSums(dfnums_to_numeric(tipranges@df)))#
#
# Set the maximum number of areas any species may occupy; this cannot be larger #
# than the number of areas you set up, but it can be smaller.#
max_range_size = 4#
#
#####################################################
#####################################################
# KEY HINT: The number of states (= number of different possible geographic ranges)#
# depends on (a) the number of areas and (b) max_range_size.#
# If you have more than about 500-600 states, the calculations will get REALLY slow,#
# since the program has to exponentiate a matrix of e.g. 600x600.  Often the computer#
# will just sit there and crunch, and never get through the calculation of the first#
# likelihood.#
# #
# (this is also what is usually happening when LAGRANGE hangs: you have too many states!)#
##
# To check the number of states for a given number of ranges, try:#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=FALSE)#
numstates_from_numareas(numareas=4, maxareas=3, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=2, include_null_range=TRUE)#
#
# Large numbers of areas have problems:#
numstates_from_numareas(numareas=10, maxareas=10, include_null_range=TRUE)#
#
# ...unless you limit the max_range_size:#
numstates_from_numareas(numareas=10, maxareas=2, include_null_range=TRUE)#
#####################################################
#####################################################
#
########################################################
########################################################
# DEC AND DEC+J ANALYSIS#
########################################################
########################################################
# NOTE: The BioGeoBEARS "DEC" model is identical with #
# the Lagrange DEC model, and should return identical#
# ML estimates of parameters, and the same #
# log-likelihoods, for the same datasets.#
##
# Ancestral state probabilities at nodes will be slightly #
# different, since BioGeoBEARS is reporting the #
# ancestral state probabilities under the global ML#
# model, and Lagrange is reporting ancestral state#
# probabilities after re-optimizing the likelihood#
# after fixing the state at each node. These will #
# be similar, but not identical. See Matzke (2014),#
# Systematic Biology, for discussion.#
##
# Also see Matzke (2014) for presentation of the #
# DEC+J model.#
########################################################
########################################################
#
########################################################
########################################################
#
########################################################
# Run DEC#
########################################################
#
# Intitialize a default model (DEC model)#
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
#
# Give BioGeoBEARS the location of the phylogeny Newick file#
BioGeoBEARS_run_object$trfn = trfn#
#
# Give BioGeoBEARS the location of the geography text file#
BioGeoBEARS_run_object$geogfn = geogfn#
#
# Input the maximum range size#
BioGeoBEARS_run_object$max_range_size = max_range_size#
#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
# 1. Here, un-comment ONLY the files you want to use.#
# 2. Also un-comment "BioGeoBEARS_run_object = section_the_tree(...", below.#
# 3. For example files see (a) extdata_dir, #
#  or (b) http://phylo.wikidot.com/biogeobears#files#
#  and BioGeoBEARS Google Group posts for further hints)#
##
# Uncomment files you wish to use in time-stratified analyses:#
BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
BioGeoBEARS_run_object$dispersal_multipliers_fn = "dispersal_multipliers.txt"#
BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
# (use more cores to speed it up; this requires#
# library(parallel) and/or library(snow). The package "parallel" #
# is now default on Macs in R 3.0+, but apparently still #
# has to be typed on some Windows machines. Note: apparently #
# parallel works on Mac command-line R, but not R.app.#
# BioGeoBEARS checks for this and resets to 1#
# core with R.app)#
#
# Sparse matrix exponentiation is an option for huge numbers of ranges/states (600+)#
# I have experimented with sparse matrix exponentiation in EXPOKIT/rexpokit,#
# but the results are imprecise and so I haven't explored it further.#
# In a Bayesian analysis, it might work OK, but the ML point estimates are#
# not identical.#
# Also, I have not implemented all functions to work with force_sparse=TRUE.#
# Volunteers are welcome to work on it!!#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC model#
# (nothing to do; defaults)#
#
# Look at the BioGeoBEARS_run_object; it's just a list of settings etc.#
BioGeoBEARS_run_object#
#
# This contains the model object#
BioGeoBEARS_run_object$BioGeoBEARS_model_object#
#
# This table contains the parameters of the model #
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table#
#
# Run this to check inputs. Read the error messages if you get them!#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# For a slow analysis, run once, then set runslow=FALSE to just #
# load the saved result.#
runslow = TRUE#
resfn = "Psychotria_DEC_M3areas_allowed_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resDEC = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDEC = res#
    }#
#
########################################################
# Run DEC+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
BioGeoBEARS_run_object$dispersal_multipliers_fn = "dispersal_multipliers.txt"#
BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resDEC$outputs@params_table["d","est"]#
estart = resDEC$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# Add j as a free parameter#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "Psychotria_DEC+J_M3areas_allowed_v1.Rdata"#
runslow = TRUE#
if (runslow)#
    {#
    #sourceall("/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resDECj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDECj = res#
    }#
#
########################################################
# PDF plots#
########################################################
pdffn = "Psychotria_DEC_vs_DEC+J_M3areas_allowed_v1.pdf"#
pdf(pdffn, width=6, height=6)#
#
########################################################
# Plot ancestral states - DEC#
########################################################
analysis_titletxt ="BioGeoBEARS DEC on Psychotria M3areas_allowed_unconstrained"#
#
# Setup#
results_object = resDEC#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
########################################################
# Plot ancestral states - DECJ#
########################################################
analysis_titletxt ="BioGeoBEARS DEC+J on Psychotria M3areas_allowed_unconstrained"#
#
# Setup#
results_object = resDECj#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res1 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()  # Turn off PDF#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr) # Plot it#
#
########################################################
########################################################
# DIVALIKE AND DIVALIKE+J ANALYSIS#
########################################################
########################################################
# NOTE: The BioGeoBEARS "DIVALIKE" model is not identical with #
# Ronquist (1997)'s parsimony DIVA. It is a likelihood#
# interpretation of DIVA, constructed by modelling DIVA's#
# processes the way DEC does, but only allowing the #
# processes DIVA allows (widespread vicariance: yes; subset#
# sympatry: no; see Ronquist & Sanmartin 2011, Figure 4).#
##
# DIVALIKE is a likelihood interpretation of parsimony#
# DIVA, and it is "like DIVA" -- similar to, but not#
# identical to, parsimony DIVA.#
##
# I thus now call the model "DIVALIKE", and you should also. ;-)#
########################################################
########################################################
#
########################################################
# Run DIVALIKE#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
BioGeoBEARS_run_object$dispersal_multipliers_fn = "dispersal_multipliers.txt"#
BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DIVALIKE model#
# Remove subset-sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "2-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "ysv*1/2"#
#
# Allow classic, widespread vicariance; all events equiprobable#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","init"] = 0.5#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","est"] = 0.5#
#
# No jump dispersal/founder-event speciation#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = 0.01#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = 0.01#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
runslow = TRUE#
resfn = "Psychotria_DIVALIKE_M3areas_allowed_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resDIVALIKE = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDIVALIKE = res#
    }#
#
########################################################
# Run DIVALIKE+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
BioGeoBEARS_run_object$dispersal_multipliers_fn = "dispersal_multipliers.txt"#
BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DIVALIKE+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resDIVALIKE$outputs@params_table["d","est"]#
estart = resDIVALIKE$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# Remove subset-sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "2-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "ysv*1/2"#
#
# Allow classic, widespread vicariance; all events equiprobable#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","init"] = 0.5#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","est"] = 0.5#
#
# Add jump dispersal/founder-event speciation#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
# Under DIVALIKE+J, the max of "j" should be 2, not 3 (as is default in DEC+J)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","min"] = 0.00001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","max"] = 1.99999#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "Psychotria_DIVALIKE+J_M3areas_allowed_v1.Rdata"#
runslow = TRUE#
if (runslow)#
    {#
    #sourceall("/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resDIVALIKEj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDIVALIKEj = res#
    }#
#
pdffn = "Psychotria_DIVALIKE_vs_DIVALIKE+J_M3areas_allowed_v1.pdf"#
pdf(pdffn, width=6, height=6)#
#
########################################################
# Plot ancestral states - DIVALIKE#
########################################################
analysis_titletxt ="BioGeoBEARS DIVALIKE on Psychotria M3areas_allowed_unconstrained"#
#
# Setup#
results_object = resDIVALIKE#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
########################################################
# Plot ancestral states - DIVALIKE+J#
########################################################
analysis_titletxt ="BioGeoBEARS DIVALIKE+J on Psychotria M3areas_allowed_unconstrained"#
#
# Setup#
results_object = resDIVALIKEj#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res1 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr)#
#
########################################################
########################################################
# BAYAREALIKE AND BAYAREALIKE+J ANALYSIS#
########################################################
########################################################
# NOTE: As with DIVA, the BioGeoBEARS BayArea-like model is #
# not identical with the full Bayesian model implemented #
# in the "BayArea" program of Landis et al. (2013). #
##
# Instead, this is a simplified likelihood interpretation#
# of the model.  Basically, in BayArea and BioGeoBEARS-BAYAREALIKE, #
# "d" and "e" work like they do in the DEC model of Lagrange #
# (and BioGeoBEARS), and then BayArea's cladogenesis assumption#
# (which is that nothing in particular happens at cladogenesis) is #
# replicated by BioGeoBEARS.#
##
# This leaves out 3 important things that are in BayArea:#
# 1. Distance dependence (you can add this with a distances #
#    matrix + the "x" parameter in BioGeoBEARS, however)#
# 2. A correction for disallowing "e" events that drive#
#    a species extinct (a null geographic range)#
# 3. The neat Bayesian sampling of histories, which allows#
#    analyses on large numbers of areas.#
##
# The main purpose of having a "BAYAREALIKE" model is #
# to test the importance of the cladogenesis model on #
# particular datasets. Does it help or hurt the data #
# likelihood if there is no special cladogenesis process?#
# #
# BAYAREALIKE is a likelihood interpretation of BayArea,#
# and it is "like BayArea" -- similar to, but not#
# identical to, Bayesian BayArea.#
# I thus now call the model "BAYAREALIKE", and you should also. ;-)#
########################################################
########################################################
#
########################################################
# Run BAYAREALIKE#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
BioGeoBEARS_run_object$dispersal_multipliers_fn = "dispersal_multipliers.txt"#
BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up BAYAREALIKE model#
# No subset sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
# No vicariance#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","est"] = 0.0#
#
# No jump dispersal/founder-event speciation#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = 0.01#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = 0.01#
#
# Adjust linkage between parameters#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "1-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/1"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "1-j"#
#
# Only sympatric/range-copying (y) events allowed, and with #
# exact copying (both descendants always the same size as the ancestor)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","init"] = 0.9999#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","est"] = 0.9999#
#
# Check the inputs#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
runslow = TRUE#
resfn = "Psychotria_BAYAREALIKE_M3areas_allowed_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resBAYAREALIKE = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resBAYAREALIKE = res#
    }#
#
########################################################
# Run BAYAREALIKE+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
BioGeoBEARS_run_object$dispersal_multipliers_fn = "dispersal_multipliers.txt"#
BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up BAYAREALIKE+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resBAYAREALIKE$outputs@params_table["d","est"]#
estart = resBAYAREALIKE$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# No subset sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
# No vicariance#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","est"] = 0.0#
#
# *DO* allow jump dispersal/founder-event speciation (set the starting value close to 0)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
# Under BAYAREALIKE+J, the max of "j" should be 1, not 3 (as is default in DEC+J) or 2 (as in DIVALIKE+J)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","max"] = 0.99999#
#
# Adjust linkage between parameters#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "1-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/1"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "1-j"#
#
# Only sympatric/range-copying (y) events allowed, and with #
# exact copying (both descendants always the same size as the ancestor)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","init"] = 0.9999#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","est"] = 0.9999#
#
# NOTE (NJM, 2014-04): BAYAREALIKE+J seems to crash on some computers, usually Windows #
# machines. I can't replicate this on my Mac machines, but it is almost certainly#
# just some precision under-run issue, when optim/optimx tries some parameter value #
# just below zero.  The "min" and "max" options on each parameter are supposed to#
# prevent this, but apparently optim/optimx sometimes go slightly beyond #
# these limits.  Anyway, if you get a crash, try raising "min" and lowering "max" #
# slightly for each parameter:#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","min"] = 0.0000001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","max"] = 4.9999999#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","min"] = 0.0000001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","max"] = 4.9999999#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","min"] = 0.00001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","max"] = 0.99999#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "Psychotria_BAYAREALIKE+J_M3areas_allowed_v1.Rdata"#
runslow = TRUE#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resBAYAREALIKEj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resBAYAREALIKEj = res#
    }#
#
pdffn = "Psychotria_BAYAREALIKE_vs_BAYAREALIKE+J_M3areas_allowed_v1.pdf"#
pdf(pdffn, width=6, height=6)#
#
########################################################
# Plot ancestral states - BAYAREALIKE#
########################################################
analysis_titletxt ="BioGeoBEARS BAYAREALIKE on Psychotria M3areas_allowed_unconstrained"#
#
# Setup#
results_object = resBAYAREALIKE#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
########################################################
# Plot ancestral states - BAYAREALIKE+J#
########################################################
analysis_titletxt ="BioGeoBEARS BAYAREALIKE+J on Psychotria M3areas_allowed_unconstrained"#
#
# Setup#
results_object = resBAYAREALIKEj#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res1 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr)#
#
##########################################################################
##########################################################################
##########################################################################
##########################################################################
# #
# CALCULATE SUMMARY STATISTICS TO COMPARE#
# DEC, DEC+J, DIVALIKE, DIVALIKE+J, BAYAREALIKE, BAYAREALIKE+J#
# #
##########################################################################
##########################################################################
##########################################################################
##########################################################################
#
##########################################################################
##########################################################################
# REQUIRED READING:#
##
# Practical advice / notes / basic principles on statistical model #
#    comparison in general, and in BioGeoBEARS:#
# http://phylo.wikidot.com/advice-on-statistical-model-comparison-in-biogeobears#
##########################################################################
##########################################################################
#
# Set up empty tables to hold the statistical results#
restable = NULL#
teststable = NULL#
#
########################################################
# Statistics -- DEC vs. DEC+J#
########################################################
# We have to extract the log-likelihood differently, depending on the #
# version of optim/optimx#
LnL_2 = get_LnL_from_BioGeoBEARS_results_object(resDEC)#
LnL_1 = get_LnL_from_BioGeoBEARS_results_object(resDECj)#
#
numparams1 = 3#
numparams2 = 2#
stats = AICstats_2models(LnL_1, LnL_2, numparams1, numparams2)#
stats#
#
# DEC, null model for Likelihood Ratio Test (LRT)#
res2 = extract_params_from_BioGeoBEARS_results_object(results_object=resDEC, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
# DEC+J, alternative model for Likelihood Ratio Test (LRT)#
res1 = extract_params_from_BioGeoBEARS_results_object(results_object=resDECj, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
#
# The null hypothesis for a Likelihood Ratio Test (LRT) is that two models#
# confer the same likelihood on the data. See: Brian O'Meara's webpage:#
# http://www.brianomeara.info/tutorials/aic#
# ...for an intro to LRT, AIC, and AICc#
#
rbind(res2, res1)#
tmp_tests = conditional_format_table(stats)#
#
restable = rbind(restable, res2, res1)#
teststable = rbind(teststable, tmp_tests)#
#
########################################################
# Statistics -- DIVALIKE vs. DIVALIKE+J#
########################################################
# We have to extract the log-likelihood differently, depending on the #
# version of optim/optimx#
LnL_2 = get_LnL_from_BioGeoBEARS_results_object(resDIVALIKE)#
LnL_1 = get_LnL_from_BioGeoBEARS_results_object(resDIVALIKEj)#
#
numparams1 = 3#
numparams2 = 2#
stats = AICstats_2models(LnL_1, LnL_2, numparams1, numparams2)#
stats#
#
# DIVALIKE, null model for Likelihood Ratio Test (LRT)#
res2 = extract_params_from_BioGeoBEARS_results_object(results_object=resDIVALIKE, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
# DIVALIKE+J, alternative model for Likelihood Ratio Test (LRT)#
res1 = extract_params_from_BioGeoBEARS_results_object(results_object=resDIVALIKEj, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
#
rbind(res2, res1)#
conditional_format_table(stats)#
#
tmp_tests = conditional_format_table(stats)#
#
restable = rbind(restable, res2, res1)#
teststable = rbind(teststable, tmp_tests)#
#
########################################################
# Statistics -- BAYAREALIKE vs. BAYAREALIKE+J#
########################################################
# We have to extract the log-likelihood differently, depending on the #
# version of optim/optimx#
LnL_2 = get_LnL_from_BioGeoBEARS_results_object(resBAYAREALIKE)#
LnL_1 = get_LnL_from_BioGeoBEARS_results_object(resBAYAREALIKEj)#
#
numparams1 = 3#
numparams2 = 2#
stats = AICstats_2models(LnL_1, LnL_2, numparams1, numparams2)#
stats#
#
# BAYAREALIKE, null model for Likelihood Ratio Test (LRT)#
res2 = extract_params_from_BioGeoBEARS_results_object(results_object=resBAYAREALIKE, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
# BAYAREALIKE+J, alternative model for Likelihood Ratio Test (LRT)#
res1 = extract_params_from_BioGeoBEARS_results_object(results_object=resBAYAREALIKEj, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
#
rbind(res2, res1)#
conditional_format_table(stats)#
#
tmp_tests = conditional_format_table(stats)#
#
restable = rbind(restable, res2, res1)#
teststable = rbind(teststable, tmp_tests)#
#
##########################################################################
# ASSEMBLE RESULTS TABLES: DEC, DEC+J, DIVALIKE, DIVALIKE+J, BAYAREALIKE, BAYAREALIKE+J#
##########################################################################
teststable$alt = c("DEC+J", "DIVALIKE+J", "BAYAREALIKE+J")#
teststable$null = c("DEC", "DIVALIKE", "BAYAREALIKE")#
row.names(restable) = c("DEC", "DEC+J", "DIVALIKE", "DIVALIKE+J", "BAYAREALIKE", "BAYAREALIKE+J")#
restable = put_jcol_after_ecol(restable)#
restable#
#
# Look at the results!!#
restable#
teststable#
#
########################################################
# Save the results tables for later -- check for e.g.#
# convergence issues#
########################################################
#
# Loads to "restable"#
save(restable, file="restable_v1.Rdata")#
load(file="restable_v1.Rdata")#
#
# Loads to "teststable"#
save(teststable, file="teststable_v1.Rdata")#
load(file="teststable_v1.Rdata")#
#
# Also save to text files#
write.table(restable, file="restable.txt", quote=FALSE, sep="\t")#
write.table(unlist_df(teststable), file="teststable.txt", quote=FALSE, sep="\t")#
#
########################################################
# Model weights of all six models#
########################################################
restable2 = restable#
#
# With AICs:#
AICtable = calc_AIC_column(LnL_vals=restable$LnL, nparam_vals=restable$numparams)#
restable = cbind(restable, AICtable)#
restable_AIC_rellike = AkaikeWeights_on_summary_table(restable=restable, colname_to_use="AIC")#
restable_AIC_rellike = put_jcol_after_ecol(restable_AIC_rellike)#
restable_AIC_rellike#
#
# With AICcs -- factors in sample size#
# samplesize = length(tr$tip.label)#
# AICtable = calc_AICc_column(LnL_vals=restable$LnL, nparam_vals=restable$numparams, samplesize=samplesize)#
# restable2 = cbind(restable2, AICtable)#
# restable_AICc_rellike = AkaikeWeights_on_summary_table(restable=restable2, colname_to_use="AICc")#
# restable_AICc_rellike = put_jcol_after_ecol(restable_AICc_rellike)#
# restable_AICc_rellike#
#
# Also save to text files#
write.table(restable_AIC_rellike, file="restable_AIC_rellike.txt", quote=FALSE, sep="\t")#
#write.table(restable_AICc_rellike, file="restable_AICc_rellike.txt", quote=FALSE, sep="\t")#
#
# Save with nice conditional formatting#
write.table(conditional_format_table(restable_AIC_rellike), file="restable_AIC_rellike_formatted.txt", quote=FALSE, sep="\t")#
#write.table(conditional_format_table(restable_AICc_rellike), file="restable_AICc_rellike_formatted.txt", quote=FALSE, sep="\t")
library(MultinomialCI)#
#
############################################
# Pick your model name:#
############################################
model_name = "DEC"#
res = resDEC#
# model_name = "DEC"#
# res = resDEC#
#
########################################################
# Plot ancestral states - DEC#
########################################################
pdffn = paste0("Psychotria_", model_name, "_v1.pdf")#
pdf(pdffn, width=6, height=6)#
#
analysis_titletxt = paste0(model_name, " on Psychotria")#
#
# Setup#
results_object = res#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()  # Turn off PDF#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr) # Plot it#
#
########################################################
# Stochastic mapping on DEC M3b stratified with islands coming up#
########################################################
clado_events_tables = NULL#
ana_events_tables = NULL#
lnum = 0#
#
########################################################
# Get the inputs for Biogeographical Stochastic Mapping#
# Note: this can be slow for large state spaces and trees, since #
# the independent likelihoods for each branch are being pre-calculated#
# E.g., for 10 areas, this requires calculation of a 1024x1024 matrix#
# for each branch.  On a tree with ~800 tips and thus ~1600 branches, this was about 1.6 gigs#
# for storage of "BSM_inputs_file.Rdata".#
# Update: 2015-09-23 -- now, if you used multicore functionality for the ML analysis,#
# the same settings will be used for get_inputs_for_stochastic_mapping().#
########################################################
BSM_inputs_fn = "BSM_inputs_file.Rdata"#
BSMinputs_runslow = TRUE#
if (BSMinputs_runslow == TRUE)#
    {#
    stochastic_mapping_inputs_list = get_inputs_for_stochastic_mapping(res=res)#
    save(stochastic_mapping_inputs_list, file=BSM_inputs_fn)#
    } else {#
    # Loads to "stochastic_mapping_inputs_list"#
    load(BSM_inputs_fn)#
    } # END if (runInputsSlow)#
#
# Check inputs (doesn't work the same on unconstr)#
names(stochastic_mapping_inputs_list)#
stochastic_mapping_inputs_list$phy2#
stochastic_mapping_inputs_list$COO_weights_columnar#
stochastic_mapping_inputs_list$unconstr#
set.seed(seed=as.numeric(54321))#
#
BSM_runslow = TRUE#
if (BSM_runslow == TRUE)#
    {#
    # Saves to: RES_clado_events_tables.Rdata#
    # Saves to: RES_ana_events_tables.Rdata#
    BSM_output = runBSM(res, stochastic_mapping_inputs_list=stochastic_mapping_inputs_list, maxnum_maps_to_try=100, nummaps_goal=50, maxtries_per_branch=40000, save_after_every_try=TRUE, savedir=getwd(), seedval=12345, wait_before_save=0.01, master_nodenum_toPrint=0)#
#
    RES_clado_events_tables = BSM_output$RES_clado_events_tables#
    RES_ana_events_tables = BSM_output$RES_ana_events_tables#
    } else {#
    # Load previously saved...#
#
    # Loads to: RES_clado_events_tables#
    load(file="RES_clado_events_tables.Rdata")#
    # Loads to: RES_ana_events_tables#
    load(file="RES_ana_events_tables.Rdata")#
    BSM_output = NULL#
    BSM_output$RES_clado_events_tables = RES_clado_events_tables#
    BSM_output$RES_ana_events_tables = RES_ana_events_tables#
    } # END if (runBSMslow == TRUE)#
#
# Extract BSM output#
clado_events_tables = BSM_output$RES_clado_events_tables#
ana_events_tables = BSM_output$RES_ana_events_tables#
head(clado_events_tables[[1]])#
head(ana_events_tables[[1]])#
length(clado_events_tables)#
length(ana_events_tables)#
#
include_null_range = TRUE#
areanames = names(tipranges@df)#
areas = areanames#
max_range_size = 4#
#
# Note: If you did something to change the states_list from the default given the number of areas, you would#
# have to manually make that change here as well! (e.g., areas_allowed matrix, or manual reduction of the states_list)#
states_list_0based = rcpp_areas_list_to_states_list(areas=areas, maxareas=max_range_size, include_null_range=include_null_range)#
#
colors_list_for_states = get_colors_for_states_list_0based(areanames=areanames, states_list_0based=states_list_0based, max_range_size=max_range_size, plot_null_range=TRUE)#
#
# For BSMs, replace white with seashell white#
colors_list_for_states[colors_list_for_states == "#FFFFFF"] = "#FFF5EE"#
#############################################
# Setup for painting a single stochastic map#
#############################################
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
stratified = TRUE#
clado_events_table = clado_events_tables[[1]]#
ana_events_table = ana_events_tables[[1]]#
#
# cols_to_get = names(clado_events_table[,-ncol(clado_events_table)])#
# colnums = match(cols_to_get, names(ana_events_table))#
# ana_events_table_cols_to_add = ana_events_table[,colnums]#
# anagenetic_events_txt_below_node = rep("none", nrow(ana_events_table_cols_to_add))#
# ana_events_table_cols_to_add = cbind(ana_events_table_cols_to_add, anagenetic_events_txt_below_node)#
# rows_to_get_TF = ana_events_table_cols_to_add$node <= length(tr$tip.label)#
# master_table_cladogenetic_events = rbind(ana_events_table_cols_to_add[rows_to_get_TF,], clado_events_table)#
#
#############################################
# Open a PDF#
#############################################
pdffn = paste0(model_name, "_single_stochastic_map_n1.pdf")#
pdf(file=pdffn, width=6, height=6)#
#
# Convert the BSM into a modified res object#
master_table_cladogenetic_events = clado_events_tables[[1]]#
resmod = stochastic_map_states_into_res(res=res, master_table_cladogenetic_events=master_table_cladogenetic_events, stratified=stratified)#
#
plot_BioGeoBEARS_results(results_object=resmod, analysis_titletxt="Stochastic map", addl_params=list("j"), label.offset=0.5, plotwhat="text", cornercoords_loc=scriptdir, root.edge=TRUE, colors_list_for_states=colors_list_for_states, skiptree=FALSE, show.tip.label=TRUE)#
#
# Paint on the branch states#
paint_stochastic_map_branches(res=resmod, master_table_cladogenetic_events=master_table_cladogenetic_events, colors_list_for_states=colors_list_for_states, lwd=5, lty=par("lty"), root.edge=TRUE, stratified=stratified)#
#
plot_BioGeoBEARS_results(results_object=resmod, analysis_titletxt="Stochastic map", addl_params=list("j"), plotwhat="text", cornercoords_loc=scriptdir, root.edge=TRUE, colors_list_for_states=colors_list_for_states, skiptree=TRUE, show.tip.label=TRUE)#
#
#############################################
# Close PDF#
#############################################
dev.off()#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr)
########################################################
# Plot all 50 stochastic maps to PDF#
########################################################
# Setup#
include_null_range = include_null_range#
areanames = areanames#
areas = areanames#
max_range_size = max_range_size#
states_list_0based = rcpp_areas_list_to_states_list(areas=areas, maxareas=max_range_size, include_null_range=include_null_range)#
colors_list_for_states = get_colors_for_states_list_0based(areanames=areanames, states_list_0based=states_list_0based, max_range_size=max_range_size, plot_null_range=TRUE)#
# For BSMs, replace white with seashell white#
colors_list_for_states[colors_list_for_states == "#FFFFFF"] = "#FFF5EE"#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
stratified = stratified#
#
# Loop through the maps and plot to PDF#
pdffn = paste0(model_name, "_", length(clado_events_tables), "BSMs_v1.pdf")#
pdf(file=pdffn, width=6, height=6)#
#
nummaps_goal = 50#
for (i in 1:nummaps_goal)#
    {#
    clado_events_table = clado_events_tables[[i]]#
    analysis_titletxt = paste0(model_name, " - Stochastic Map #", i, "/", nummaps_goal)#
    plot_BSM(results_object=res, clado_events_table=clado_events_table, stratified=stratified, analysis_titletxt=analysis_titletxt, addl_params=list("j"), label.offset=0.5, plotwhat="text", cornercoords_loc=scriptdir, root.edge=TRUE, colors_list_for_states=colors_list_for_states, show.tip.label=TRUE, include_null_range=include_null_range)#
    } # END for (i in 1:nummaps_goal)#
#
dev.off()#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr)#
#
########################################################
# Summarize stochastic map tables#
########################################################
length(clado_events_tables)#
length(ana_events_tables)#
#
head(clado_events_tables[[1]][,-20])#
tail(clado_events_tables[[1]][,-20])#
#
head(ana_events_tables[[1]])#
tail(ana_events_tables[[1]])#
#
areanames = names(tipranges@df)#
actual_names = areanames#
actual_names#
#
# Get the dmat and times (if any)#
dmat_times = get_dmat_times_from_res(res=res, numstates=NULL)#
dmat_times#
#
# Extract BSM output#
clado_events_tables = BSM_output$RES_clado_events_tables#
ana_events_tables = BSM_output$RES_ana_events_tables#
#
# Simulate the source areas#
BSMs_w_sourceAreas = simulate_source_areas_ana_clado(res, clado_events_tables, ana_events_tables, areanames)#
clado_events_tables = BSMs_w_sourceAreas$clado_events_tables#
ana_events_tables = BSMs_w_sourceAreas$ana_events_tables
counts_list = count_ana_clado_events(clado_events_tables, ana_events_tables, areanames, actual_names)#
#
summary_counts_BSMs = counts_list$summary_counts_BSMs#
print(conditional_format_table(summary_counts_BSMs))#
#
# Histogram of event counts#
hist_event_counts(counts_list, pdffn=paste0(model_name, "_histograms_of_event_counts.pdf"))#
#
########################################################
# Print counts to files#
########################################################
tmpnames = names(counts_list)#
cat("\n\nWriting tables* of counts to tab-delimited text files:\n(* = Tables have dimension=2 (rows and columns). Cubes (dimension 3) and lists (dimension 1) will not be printed to text files.) \n\n")#
for (i in 1:length(tmpnames))#
    {#
    cmdtxt = paste0("item = counts_list$", tmpnames[i])#
    eval(parse(text=cmdtxt))#
#
    # Skip cubes#
    if (length(dim(item)) != 2)#
        {#
        next()#
        }#
#
    outfn = paste0(tmpnames[i], ".txt")#
    if (length(item) == 0)#
        {#
        cat(outfn, " -- NOT written, *NO* events recorded of this type", sep="")#
        cat("\n")#
        } else {#
        cat(outfn)#
        cat("\n")#
        write.table(conditional_format_table(item), file=outfn, quote=FALSE, sep="\t", col.names=TRUE, row.names=TRUE)#
        } # END if (length(item) == 0)#
    } # END for (i in 1:length(tmpnames))#
cat("...done.\n")#
#
########################################################
# Check that ML ancestral state/range probabilities and#
# the mean of the BSMs approximately line up#
########################################################
library(MultinomialCI)    # For 95% CIs on BSM counts#
check_ML_vs_BSM(res, clado_events_tables, model_name, tr=NULL, plot_each_node=FALSE, linreg_plot=TRUE, MultinomialCI=TRUE)
library(phytools)#
Q = matrix(c(-3,1,1,1,1,-3,1,1,1,1,-3,1,1,1,1,-3),4,4)#
rownames(Q) = letters[1:4]#
colnames(Q) = letters[1:4]#
Q#
#
set.seed(seed=54321)#
simdata = sim.history(tree=tr, Q=Q, nsim=1)#
tipdata = simdata$states#
tipdata#
#
set.seed(seed=54321)#
tr2 = make.simmap(tree=tr, x=tipdata, model="ER")#
tr2#
tr2$mapped.edge#
#
set.seed(seed=54321)#
tr2 = make.simmap(tree=tr, x=sort(tipdata), model="ER")#
tr2#
tr2$mapped.edge#
#
# Same!#
# Plot to PDF#
pdffn = "phytools_simmap.pdf"#
pdf(file=pdffn, width=6, height=6)#
#
plotSimmap(tr2,lwd=3)#
#
dev.off()#
cmdstr = paste0("open ", pdffn)#
system(cmdstr)
returned_mats = get_Qmat_COOmat_from_BioGeoBEARS_run_object(BioGeoBEARS_run_object=resDEC$inputs)#
ranges_list = returned_mats$ranges_list#
########################################################
# Convert a time-stratified BSM to a phytools BSM#
########################################################
#
res = resDEC#
clado_events_table = clado_events_tables[[1]]#
ana_events_table = ana_events_tables[[1]]#
#
tr_wSimmap = BSM_to_phytools_SM(res=resDEC, clado_events_table=clado_events_tables[[6]], ana_events_table=ana_events_tables[[6]])
tr_wSimmap
summary(tr_wSimmap)#
print(tr_wSimmap)#
countSimmap(tr_wSimmap)
tr_wSimmap
names(tr_wSimmap)
tr_wSimmap$mapped.edge
tr_wSimmap$maps
# Plot to PDF#
pdffn = "BSM_in_phytools_simmap_format.pdf"#
pdf(file=pdffn, width=6, height=6)#
#
cols = setNames(colors_list_for_states, ranges_list) #
plotSimmap(tr_wSimmap, lwd=3, colors=cols)#
#
dev.off()#
cmdstr = paste0("open ", pdffn)#
system(cmdstr)
simmaps_list = BSMs_to_phytools_SMs(res=resDEC, clado_events_tables=clado_events_tables, ana_events_tables=ana_events_tables)#
#
summary(simmaps_list)#
print(simmaps_list)#
countSimmap(simmaps_list) # Gets big fast, for large states lists
simmaps_list$maps
simmaps_list[[1]]$maps
pdffn = "50BSMs_in_phytools_simmap_format.pdf"#
pdf(file=pdffn, width=6, height=6)#
#
cols = setNames(colors_list_for_states, ranges_list) #
plotSimmap(simmaps_list, colors=cols, lwd=3, hold=FALSE, add=FALSE, plot=TRUE)#
#
dev.off()#
cmdstr = paste0("open ", pdffn)#
system(cmdstr)
system(cmdstr)
length(simmaps_list)
dev.off()
dev.off()
pdffn = "50BSMs_in_phytools_simmap_format.pdf"#
pdf(file=pdffn, width=6, height=6)#
#
cols = setNames(colors_list_for_states, ranges_list) #
#
for (i in 1:length(simmaps_list)#
	{#
	plotSimmap(simmaps_list[[i]], colors=cols, lwd=3, hold=FALSE, add=FALSE, plot=TRUE)#
	}#
#
dev.off()#
cmdstr = paste0("open ", pdffn)#
system(cmdstr)
pdffn = "50BSMs_in_phytools_simmap_format.pdf"#
pdf(file=pdffn, width=6, height=6)#
#
cols = setNames(colors_list_for_states, ranges_list) #
#
for (i in 1:length(simmaps_list))#
	{#
	plotSimmap(simmaps_list[[i]], colors=cols, lwd=3, hold=FALSE, add=FALSE, plot=TRUE)#
	}#
#
dev.off()#
cmdstr = paste0("open ", pdffn)#
system(cmdstr)
?extract.clade
reconstructed_points_table
#install.packages("openxlsx")#
#install.packages("rgplates")#
#install.packages("geojsonsf")#
library(openxlsx)#
library(rgplates)#
library(geojsonsf)#
library(tidyverse)#
library(sf)#
#
#set working directory#
wd = "~/ts/labs/lab03/_Gplates/"#
setwd(wd)#
#
fn = "12_regions_points.xlsx"#
xls = openxlsx::read.xlsx(xlsxFile=fn, sheet="present")#
xls#
#
# Plot your polygons on a map:#
world_extent = NULL#
world_extent$long = c(-180,180,180,-180)#
world_extent$lat = c(90,90,-90,-90)#
df <- data.frame(lon=world_extent$long, lat=world_extent$lat)#
world_polygon <- df %>%#
st_as_sf(coords = c("lon", "lat"), crs = 4326) %>%#
summarise(geometry = st_combine(geometry)) %>%#
st_cast("POLYGON")#
#plot(world_polygon, col="lightblue")#
plot(world_polygon, col="lightblue", reset=FALSE)#
#
list_of_polygons = list()#
area_names = unique(xls$area)#
cols = rainbow(n=length(area_names))#
i = 1#
for (i in 1:length(area_names))#
	{#
	rowTF = xls$area == area_names[i]#
	tmpxls = xls[rowTF,]#
	df <- data.frame(lon=tmpxls$long, lat=tmpxls$lat)#
	tmp_polygon <- df %>%#
  st_as_sf(coords = c("lon", "lat"), crs = 4326) %>%#
  summarise(geometry = st_combine(geometry)) %>%#
  st_cast("POLYGON")#
	tmp_polygon#
	plot(tmp_polygon, col=cols[i], add=TRUE)#
	}#
#
# doesn't quite look right!#
#
# Try again:#
world_extent = NULL#
world_extent$long = c(-180,180,180,-180)#
world_extent$lat = c(90,90,-90,-90)#
df <- data.frame(lon=world_extent$long, lat=world_extent$lat)#
world_polygon <- df %>%#
st_as_sf(coords = c("lon", "lat"), crs = 4326) %>%#
summarise(geometry = st_combine(geometry)) %>%#
st_cast("POLYGON")#
#plot(world_polygon, col="lightblue")#
plot(world_polygon, col="lightblue", reset=FALSE)#
#
list_of_polygons = list()#
area_names = unique(xls$area)#
cols = rainbow(n=length(area_names))#
i = 8#
for (i in 1:length(area_names))#
	{#
	rowTF = xls$area == area_names[i]#
	tmpxls = xls[rowTF,]#
	# edit points just east of -180, for asia#
	if (area_names[i] == "P_Palearctic")#
		{#
		tmpxls$long[tmpxls$long < -169] = 180#
		}#
	df <- data.frame(lon=tmpxls$long, lat=tmpxls$lat)#
	tmp_polygon <- df %>%#
  st_as_sf(coords = c("lon", "lat"), crs = 4326) %>%#
  summarise(geometry = st_combine(geometry)) %>%#
  st_cast("POLYGON")#
	tmp_polygon#
	plot(tmp_polygon, col=cols[i], add=TRUE)#
	}#
########################################################
# Reconstruct those points back in time#
########################################################
#
ages = seq(from=1, to=100, by=1)#
reconstructed_points_table = xls#
#
cat("\nReconstructing paleolongitudes (x) & paleolatitudes (y) for ", length(ages), " ages, ending at ", max(ages), "...", sep="")#
i=1#
for (i in 1:length(ages))#
	{#
  # Nice to print each step so you can see timing#
  cat(ages[i], ",", sep="")#
  tmpresult = rgplates::reconstruct(x=xls[,c("long","lat")], age=ages[i], model="MERDITH2021")#
  # Change the names of the columns to specify age#
  colnames(tmpresult) = paste0(c("long_","lat_"), ages[i])#
  tmpresult#
  # Add tmpresult to table#
  reconstructed_points_table = cbind(reconstructed_points_table, tmpresult)#
	}#
#
reconstructed_points_table
head(reconstructed_points_table[,1:7])#
tail(reconstructed_points_table[,1:7])
dim(reconstructed_points_table)
ages = c(0,ages)
age
ages
sf
library(sf)
library(sf)#
library(rgplates)
library(openxlsx)#
library(rgplates)#
library(geojsonsf)#
library(tidyverse)
pdffn = "polygons_through_time.pdf"#
pdf(file=pdffn, width=6, height=6)#
#
# Try again:#
world_extent = NULL#
world_extent$long = c(-180,180,180,-180)#
world_extent$lat = c(90,90,-90,-90)#
df <- data.frame(lon=world_extent$long, lat=world_extent$lat)#
world_polygon <- df %>%#
st_as_sf(coords = c("lon", "lat"), crs = 4326) %>%#
summarise(geometry = st_combine(geometry)) %>%#
st_cast("POLYGON")#
#plot(world_polygon, col="lightblue")#
#plot(world_polygon, col="lightblue", reset=FALSE)#
#
timeval = 1+2*(40)#
list_of_polygons = list()#
area_names = unique(xls$area)#
cols = rainbow(n=length(area_names))#
i = 8#
cat("Plotting polygons through time...a=")
reconstruction_col = 0#
for (ai in 1:length((ages)))#
	{#
	a = ages[ai]#
	cat(a,",", sep="")#
	timeval = ages[ai]#
	reconstruction_col = 2*ai#
	plot(world_polygon, col="lightblue", reset=FALSE, xlim=c(-180, 180), ylim=c(-90,90))#
	title(paste0(a, " million years ago"))#
#
	for (i in 1:length(area_names))#
		{#
		rowTF = xls$area == area_names[i]#
		tmpxls = reconstructed_points_table[rowTF,c(reconstruction_col:(reconstruction_col+1))]#
		naTF1 = is.na(tmpxls[,1])#
		naTF2 = is.na(tmpxls[,2])#
		naTF = (naTF1 + naTF2) == 0#
		tmpxls = tmpxls[naTF,]#
		# edit points just east of -180, for asia#
		if (area_names[i] != "N_Nearctic")#
			{#
			tmpxls$long[tmpxls$long < -169] = 179#
			}#
		df <- data.frame(lon=tmpxls$long, lat=tmpxls$lat)#
		tmp_polygon <- df %>%#
		st_as_sf(coords = c("lon", "lat"), crs = 4326) %>%#
		summarise(geometry = st_combine(geometry)) %>%#
		st_cast("POLYGON")#
		tmp_polygon#
		plot(tmp_polygon, col=cols[i], add=TRUE)#
		}#
	} # END for (a in ages)#
#
dev.off()#
cmdstr = paste0("open ", pdffn)#
system(cmdstr)
xcol = 2#
min_dist = array(data=NA, dim=c(length(area_names), length(area_names), ((ncol(reconstructed_points_table)-1)/2)))#
centroid_dist = array(data=NA, dim=c(length(area_names), length(area_names), ((ncol(reconstructed_points_table)-1)/2)))
xcol = 2#
min_dist = array(data=NA, dim=c(length(area_names), length(area_names), ((ncol(reconstructed_points_table)-1)/2)))#
centroid_dist = array(data=NA, dim=c(length(area_names), length(area_names), ((ncol(reconstructed_points_table)-1)/2)))
dim(min_dist)
dim(centroid_dist)
cat("\nCalculating distances for time slice i=\n")
i=1#
j=1#
k=2
rowTF = xls$area == area_names[j]#
			tmpxls = xls[rowTF,]#
			rowTF2 = xls$area == area_names[k]#
			tmpxls2 = xls[rowTF2,]
tmpxls
tmpxls2
long1 = reconstructed_points_table[rowTF,xcol]#
			lat1 = reconstructed_points_table[rowTF,xcol+1]
long1 = reconstructed_points_table[rowTF,xcol]#
			lat1 = reconstructed_points_table[rowTF,xcol+1]#
			naTF1 = is.na(long1)#
			naTF2 = is.na(lat1)#
			naTF = (naTF1 + naTF2) > 0#
			long1 = long1[naTF == FALSE]#
			lat1 = lat1[naTF == FALSE]
long2 = reconstructed_points_table[rowTF2,xcol]#
			lat2 = reconstructed_points_table[rowTF2,xcol+1]#
			naTF1 = is.na(long2)#
			naTF2 = is.na(lat2)#
			naTF = (naTF1 + naTF2) > 0#
			long2 = long2[naTF == FALSE]#
			lat2 = lat2[naTF == FALSE]
sum(naTF)
area1 = cbind(long1,lat1)#
			colnames(area1) = c("x","y")#
			area2 = cbind(long2,lat2)#
			colnames(area2) = c("x","y")
area1
area2
ensure_closure = FALSE#
			if (ensure_closure == TRUE)#
				{#
				# Make sure the last coordinate matches the first coordinate#
				# (this is usually the case, but coordinates can get dropped)#
				if ( (area1[,"x"][1] != area1[,"x"][length(area1[,"x"])]) || (area1[,"y"][1] != area1[,"y"][length(area1[,"y"])]) )#
					{#
					area1 = rbind(area1, area1[1,])#
					}#
				if ( (area2[,"x"][1] != area2[,"x"][length(area2[,"x"])]) || (area2[,"y"][1] != area2[,"y"][length(area2[,"y"])]) )#
					{#
					area2 = rbind(area2, area2[1,])#
					}#
				} # END if (ensure_closure == TRUE)#
			make_points_unique = FALSE#
			if (make_points_unique == TRUE)#
				{#
				pts_txt = apply(X=area1, MARGIN=1, FUN=paste0, collapse="_")#
				unique(pts_txt)#
				nums_to_keep = match(x=unique(pts_txt), table=pts_txt)#
				area1 = area1[nums_to_keep,]#
#
				pts_txt = apply(X=area2, MARGIN=1, FUN=paste0, collapse="_")#
				unique(pts_txt)#
				nums_to_keep = match(x=unique(pts_txt), table=pts_txt)#
				area2 = area2[nums_to_keep,]#
				}
area1_mp = st_multipoint(x=area1, dim="XY") %>% st_sfc(crs = 4326)#
			area2_mp = st_multipoint(x=area2, dim="XY") %>% st_sfc(crs = 4326)
plot(area1_mp)
plot(area2_mp)
z = try(st_distance(x=area1_mp, y=area2_mp))
z
st_centroid(area1_mp)
st_centroid(area2_mp)
z2 = try(st_distance(x=st_centroid(area1_mp), y=st_centroid(area2_mp)))
xcol = 2#
min_dist = array(data=NA, dim=c(length(area_names), length(area_names), ((ncol(reconstructed_points_table)-1)/2)))#
centroid_dist = array(data=NA, dim=c(length(area_names), length(area_names), ((ncol(reconstructed_points_table)-1)/2)))#
i=1#
j=1#
k=2#
cat("\nCalculating distances for time slice i=\n")#
for (i in 1:((ncol(reconstructed_points_table)-1)/2))#
	{#
	cat(i, ",", sep="")#
	for (j in 1:length(area_names))#
		{#
		for (k in 1:length(area_names))#
			{#
			rowTF = xls$area == area_names[j]#
			tmpxls = xls[rowTF,]#
			rowTF2 = xls$area == area_names[k]#
			tmpxls2 = xls[rowTF2,]#
			# Edit to remove NA points - #
			# Gplates can LOSE points back in time#
			# e.g. if the tectonic plate "disappears"#
			long1 = reconstructed_points_table[rowTF,xcol]#
			lat1 = reconstructed_points_table[rowTF,xcol+1]#
			naTF1 = is.na(long1)#
			naTF2 = is.na(lat1)#
			naTF = (naTF1 + naTF2) > 0#
			long1 = long1[naTF == FALSE]#
			lat1 = lat1[naTF == FALSE]#
#
			long2 = reconstructed_points_table[rowTF2,xcol]#
			lat2 = reconstructed_points_table[rowTF2,xcol+1]#
			naTF1 = is.na(long2)#
			naTF2 = is.na(lat2)#
			naTF = (naTF1 + naTF2) > 0#
			long2 = long2[naTF == FALSE]#
			lat2 = lat2[naTF == FALSE]#
			area1 = cbind(long1,lat1)#
			colnames(area1) = c("x","y")#
			area2 = cbind(long2,lat2)#
			colnames(area2) = c("x","y")#
#
			ensure_closure = FALSE#
			if (ensure_closure == TRUE)#
				{#
				# Make sure the last coordinate matches the first coordinate#
				# (this is usually the case, but coordinates can get dropped)#
				if ( (area1[,"x"][1] != area1[,"x"][length(area1[,"x"])]) || (area1[,"y"][1] != area1[,"y"][length(area1[,"y"])]) )#
					{#
					area1 = rbind(area1, area1[1,])#
					}#
				if ( (area2[,"x"][1] != area2[,"x"][length(area2[,"x"])]) || (area2[,"y"][1] != area2[,"y"][length(area2[,"y"])]) )#
					{#
					area2 = rbind(area2, area2[1,])#
					}#
				} # END if (ensure_closure == TRUE)#
			make_points_unique = FALSE#
			if (make_points_unique == TRUE)#
				{#
				pts_txt = apply(X=area1, MARGIN=1, FUN=paste0, collapse="_")#
				unique(pts_txt)#
				nums_to_keep = match(x=unique(pts_txt), table=pts_txt)#
				area1 = area1[nums_to_keep,]#
#
				pts_txt = apply(X=area2, MARGIN=1, FUN=paste0, collapse="_")#
				unique(pts_txt)#
				nums_to_keep = match(x=unique(pts_txt), table=pts_txt)#
				area2 = area2[nums_to_keep,]#
				}#
			#area1_alphahull = alphahull::ahull(x=area1, alpha=1)#
			#area2_alphahull = alphahull::ahull(x=area2, alpha=1)#
			# doesn't like non-convex points#
			#area1_convexhull = spatstat.geom::convexhull.xy(area1)#
			#area2_convexhull = spatstat.geom::convexhull.xy(area2)#
			#area1_ahull_mat = area1_alphahull$xahull#
			#area2_ahull_mat = area2_alphahull$xahull#
			#colnames(area1_ahull_mat) = c("x","y")#
			#colnames(area2_ahull_mat) = c("x","y")#
			#area1_ahull_mat = rbind(area1_ahull_mat, area1_ahull_mat[1,])#
			#area2_ahull_mat = rbind(area2_ahull_mat, area2_ahull_mat[1,])#
			# CRS: Coordinate Reference System#
			# WGS84 (EPSG:4326)#
			#poly1 <- st_polygon(list(area1_ahull_mat)) %>% st_sfc(crs = 4326)#
			#poly2 <- st_polygon(list(area2_ahull_mat)) %>% st_sfc(crs = 4326)#
			area1_mp = st_multipoint(x=area1, dim="XY") %>% st_sfc(crs = 4326)#
			area2_mp = st_multipoint(x=area2, dim="XY") %>% st_sfc(crs = 4326)#
			st_centroid(area1_mp)#
			#poly1 <- st_concave_hull(x=st_multipoint(x=area1, dim="XY"), ratio=0.5, allow_holes=FALSE) %>% st_sfc(crs = 4326)#
			#poly2 <- st_concave_hull(st_multipoint(x=area2, dim="XY"), ratio=0.5, allow_holes=FALSE) %>% st_sfc(crs = 4326)#
			#z = suppressWarnings(try(min(spDists(x=area1, y=area2, longlat=TRUE, diagonal=FALSE), na.rm=TRUE)))#
			#z = suppressWarnings(try(st_distance(x=poly1, y=poly2)))#
			z = try(st_distance(x=area1_mp, y=area2_mp))#
			z2 = try(st_distance(x=st_centroid(area1_mp), y=st_centroid(area2_mp)))#
			if (class(z) == "try-error")#
				{#
				min_dist[j,k,i] = NA#
				} else {#
				min_dist[j,k,i] = z#
				}#
			if (class(z2) == "try-error")#
				{#
				centroid_dist[j,k,i] = NA#
				} else {#
				centroid_dist[j,k,i] = z2#
				}#
			}#
		}#
	xcol = xcol+2#
	}
set_diag_to_NA <- function(ma)#
	{#
	diag(ma) = NA#
	}#
#
set_diag_to_NA_array <- function(ma)#
	{#
	TFmat = matrix(data=FALSE, nrow=dim(ma)[1], ncol=dim(ma)[2])#
	diag(TFmat) = TRUE#
	num_slices = dim(ma)[3]#
	for (n in 1:num_slices)#
		{#
		diag(ma[,,n]) = NA#
		}#
	return(ma)#
	}
centroid_dist[1:5,1:5, 1]
centroid_dist[1:5,1:5, 10]
centroid_dist[1:5,1:5, 100]
min_dist[1:5,1:5, 100]
min_dist[1:5,1:5, 1]
set_diag_to_NA <- function(ma)#
	{#
	diag(ma) = NA#
	}#
#
set_diag_to_NA_array <- function(ma)#
	{#
	TFmat = matrix(data=FALSE, nrow=dim(ma)[1], ncol=dim(ma)[2])#
	diag(TFmat) = TRUE#
	num_slices = dim(ma)[3]#
	for (n in 1:num_slices)#
		{#
		diag(ma[,,n]) = NA#
		}#
	return(ma)#
	}
xvals = c(set_diag_to_NA_array(centroid_dist))#
yvals = c(set_diag_to_NA_array(min_dist))#
naTF1 = !is.na(xvals)#
naTF2 = !is.na(yvals)#
naTF = (naTF1 + naTF2) == 2#
xvals = xvals[naTF] / 1000#
yvals = yvals[naTF] / 1000
xvals = c(set_diag_to_NA_array(centroid_dist))#
yvals = c(set_diag_to_NA_array(min_dist))#
naTF1 = !is.na(xvals)#
naTF2 = !is.na(yvals)#
naTF = (naTF1 + naTF2) == 2#
xvals = xvals[naTF] / 1000#
yvals = yvals[naTF] / 1000
linear_regression_plot(x=xvals, y=yvals, xlabel="centroid distance (km)", ylabel="minimum distance (km)", tmppch=".", pointscol="blue")
title("Centroid distance vs. minimum distance, 0-100 Ma")
rgplates::reconstruct(x=xls[,c("long","lat")], age=ages[i], model="MERDITH2021")
?rgplates::reconstruct(x=xls[,c("long","lat")], age=ages[i], model="MERDITH2021")
# Load the package (after installation, see above).#
library(GenSA)    # GenSA is better than optimx (although somewhat slower)#
library(optimx)    # GenSA is better than optimx (although somewhat slower)#
library(FD)       # for FD::maxent() (make sure this is up-to-date)#
library(snow)     # (if you want to use multicore functionality; some systems/R versions prefer library(parallel), try either)#
library(parallel)#
#
########################################################
# 2018-10-10 update: I have been putting the #
# updates on CRAN/GitHub#
# You should use:#
# rexpokit version 0.26.6 from CRAN#
# cladoRcpp version 0.15 from CRAN#
# BioGeoBEARS version 1.1 from GitHub, install with:#
# library(devtools)#
# devtools::install_github(repo="nmatzke/BioGeoBEARS")#
########################################################
library(rexpokit)#
library(cladoRcpp)#
library(BioGeoBEARS)#
########################################################
# SETUP: YOUR WORKING DIRECTORY#
########################################################
# You will need to set your working directory to match your local system#
#
# Note these very handy functions!#
# Command "setwd(x)" sets your working directory#
# Command "getwd()" gets your working directory and tells you what it is.#
# Command "list.files()" lists the files in your working directory#
# To get help on any command, use "?".  E.g., "?list.files"#
#
# Set your working directory for output files#
# default here is your home directory ("~")#
# Change this as you like#
# wd = slashslash(paste0(addslash(extdata_dir), "/examples/BSM_Psychotria/M3areas_allowed/"))#
# setwd(wd)#
#
wd = "~/GitHub/BioGeoBEARS/inst/extdata/examples/Psychotria_M3strat/BSM_to_simmap/"#
setwd(wd)#
#
# Double-check your working directory with getwd()#
getwd()#
#
########################################################
# SETUP: Extension data directory#
########################################################
# When R packages contain extra files, they are stored in the "extdata" directory #
# inside the installed package.#
##
# BioGeoBEARS contains various example files and scripts in its extdata directory.#
# #
# Each computer operating system might install BioGeoBEARS in a different place, #
# depending on your OS and settings. #
# #
# However, you can find the extdata directory like this:#
extdata_dir = np(system.file("extdata", package="BioGeoBEARS"))#
extdata_dir#
list.files(extdata_dir)#
# "system.file" looks in the directory of a specified package (in this case BioGeoBEARS)#
# The function "np" is just a shortcut for normalizePath(), which converts the #
# path to the format appropriate for your system (e.g., Mac/Linux use "/", but #
# Windows uses "\\", if memory serves).#
#
# Even when using your own data files, you should KEEP these commands in your #
# script, since the plot_BioGeoBEARS_results function needs a script from the #
# extdata directory to calculate the positions of "corners" on the plot. This cannot#
# be made into a straight up BioGeoBEARS function because it uses C routines #
# from the package APE which do not pass R CMD check for some reason.#
#
########################################################
# SETUP: YOUR TREE FILE AND GEOGRAPHY FILE#
########################################################
# Example files are given below. To run your own data,#
# make the below lines point to your own files, e.g.#
# trfn = "/mydata/frogs/frogBGB/tree.newick"#
# geogfn = "/mydata/frogs/frogBGB/geog.data"#
#
########################################################
# Phylogeny file#
# Notes: #
# 1. Must be binary/bifurcating: no polytomies#
# 2. No negative branchlengths (e.g. BEAST MCC consensus trees sometimes have negative branchlengths)#
# 3. Be careful of very short branches, as BioGeoBEARS will interpret ultrashort branches as direct ancestors#
# 4. You can use non-ultrametric trees, but BioGeoBEARS will interpret any tips significantly below the #
#    top of the tree as fossils!  This is only a good idea if you actually do have fossils in your tree,#
#    as in e.g. Wood, Matzke et al. (2013), Systematic Biology.#
# 5. The default settings of BioGeoBEARS make sense for trees where the branchlengths are in units of #
#    millions of years, and the tree is 1-1000 units tall. If you have a tree with a total height of#
#    e.g. 0.00001, you will need to adjust e.g. the max values of d and e, or (simpler) multiply all#
#    your branchlengths to get them into reasonable units.#
# 6. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
########################################################
# This is the example Newick file for Hawaiian Psychotria#
# (from Ree & Smith 2008)#
# "trfn" = "tree file name"#
trfn = "tree.newick"#
#
# Look at the raw Newick file:#
moref(trfn)#
pdffn = "tree.pdf"#
pdf(file=pdffn, width=6, height=6)#
#
# Look at your phylogeny:#
tr = read.tree(trfn)#
tr#
plot(tr)#
title("Example tree")#
axisPhylo() # plots timescale#
dev.off()#
#
cmdstr = paste0("open ", pdffn)#
system(cmdstr)#
########################################################
# Geography file#
# Notes:#
# 1. This is a PHYLIP-formatted file. This means that in the #
#    first line, #
#    - the 1st number equals the number of rows (species)#
#    - the 2nd number equals the number of columns (number of areas)#
#    - after a tab, put the areas in parentheses, with spaces: (A B C D)#
##
# 1.5. Example first line:#
#    10    4    (A B C D)#
# #
# 2. The second line, and subsequent lines:#
#    speciesA    0110#
#    speciesB    0111#
#    speciesC    0001#
#         ...#
# #
# 2.5a. This means a TAB between the species name and the area 0/1s#
# 2.5b. This also means NO SPACE AND NO TAB between the area 0/1s.#
# #
# 3. See example files at:#
#    http://phylo.wikidot.com/biogeobears#files#
# #
# 4. Make you understand what a PLAIN-TEXT EDITOR is:#
#    http://phylo.wikidot.com/biogeobears#texteditors#
##
# 3. The PHYLIP format is the same format used for C++ LAGRANGE geography files.#
##
# 4. All names in the geography file must match names in the phylogeny file.#
##
# 5. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
##
# 6. Operational taxonomic units (OTUs) should ideally be phylogenetic lineages, #
#    i.e. genetically isolated populations.  These may or may not be identical #
#    with species.  You would NOT want to just use specimens, as each specimen #
#    automatically can only live in 1 area, which will typically favor DEC+J #
#    models.  This is fine if the species/lineages really do live in single areas,#
#    but you wouldn't want to assume this without thinking about it at least. #
#    In summary, you should collapse multiple specimens into species/lineages if #
#    data indicates they are the same genetic population.#
#######################################################
#
# This is the example geography file for Hawaiian Psychotria#
# (from Ree & Smith 2008)#
geogfn = "geog.data"#
#
# Look at the raw geography text file:#
moref(geogfn)#
#
# Look at your geographic range data:#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Maximum range size observed:#
max(rowSums(dfnums_to_numeric(tipranges@df)))#
#
# Set the maximum number of areas any species may occupy; this cannot be larger #
# than the number of areas you set up, but it can be smaller.#
max_range_size = 4#
#
#####################################################
#####################################################
# KEY HINT: The number of states (= number of different possible geographic ranges)#
# depends on (a) the number of areas and (b) max_range_size.#
# If you have more than about 500-600 states, the calculations will get REALLY slow,#
# since the program has to exponentiate a matrix of e.g. 600x600.  Often the computer#
# will just sit there and crunch, and never get through the calculation of the first#
# likelihood.#
# #
# (this is also what is usually happening when LAGRANGE hangs: you have too many states!)#
##
# To check the number of states for a given number of ranges, try:#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=FALSE)#
numstates_from_numareas(numareas=4, maxareas=3, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=2, include_null_range=TRUE)#
#
# Large numbers of areas have problems:#
numstates_from_numareas(numareas=10, maxareas=10, include_null_range=TRUE)#
#
# ...unless you limit the max_range_size:#
numstates_from_numareas(numareas=10, maxareas=2, include_null_range=TRUE)#
#####################################################
#####################################################
#
########################################################
########################################################
# DEC AND DEC+J ANALYSIS#
########################################################
########################################################
# NOTE: The BioGeoBEARS "DEC" model is identical with #
# the Lagrange DEC model, and should return identical#
# ML estimates of parameters, and the same #
# log-likelihoods, for the same datasets.#
##
# Ancestral state probabilities at nodes will be slightly #
# different, since BioGeoBEARS is reporting the #
# ancestral state probabilities under the global ML#
# model, and Lagrange is reporting ancestral state#
# probabilities after re-optimizing the likelihood#
# after fixing the state at each node. These will #
# be similar, but not identical. See Matzke (2014),#
# Systematic Biology, for discussion.#
##
# Also see Matzke (2014) for presentation of the #
# DEC+J model.#
########################################################
########################################################
#
########################################################
########################################################
#
########################################################
# Run DEC#
########################################################
#
# Intitialize a default model (DEC model)#
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
#
# Give BioGeoBEARS the location of the phylogeny Newick file#
BioGeoBEARS_run_object$trfn = trfn#
#
# Give BioGeoBEARS the location of the geography text file#
BioGeoBEARS_run_object$geogfn = geogfn#
#
# Input the maximum range size#
BioGeoBEARS_run_object$max_range_size = max_range_size#
#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
# 1. Here, un-comment ONLY the files you want to use.#
# 2. Also un-comment "BioGeoBEARS_run_object = section_the_tree(...", below.#
# 3. For example files see (a) extdata_dir, #
#  or (b) http://phylo.wikidot.com/biogeobears#files#
#  and BioGeoBEARS Google Group posts for further hints)#
##
# Uncomment files you wish to use in time-stratified analyses:#
BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
BioGeoBEARS_run_object$dispersal_multipliers_fn = "dispersal_multipliers.txt"#
BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
# (use more cores to speed it up; this requires#
# library(parallel) and/or library(snow). The package "parallel" #
# is now default on Macs in R 3.0+, but apparently still #
# has to be typed on some Windows machines. Note: apparently #
# parallel works on Mac command-line R, but not R.app.#
# BioGeoBEARS checks for this and resets to 1#
# core with R.app)#
#
# Sparse matrix exponentiation is an option for huge numbers of ranges/states (600+)#
# I have experimented with sparse matrix exponentiation in EXPOKIT/rexpokit,#
# but the results are imprecise and so I haven't explored it further.#
# In a Bayesian analysis, it might work OK, but the ML point estimates are#
# not identical.#
# Also, I have not implemented all functions to work with force_sparse=TRUE.#
# Volunteers are welcome to work on it!!#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC model#
# (nothing to do; defaults)#
#
# Look at the BioGeoBEARS_run_object; it's just a list of settings etc.#
BioGeoBEARS_run_object#
#
# This contains the model object#
BioGeoBEARS_run_object$BioGeoBEARS_model_object#
#
# This table contains the parameters of the model #
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table#
#
# Run this to check inputs. Read the error messages if you get them!#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# For a slow analysis, run once, then set runslow=FALSE to just #
# load the saved result.#
runslow = TRUE#
resfn = "Psychotria_DEC_M3areas_allowed_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resDEC = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDEC = res#
    }
########################################################
# Run DEC+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
BioGeoBEARS_run_object$dispersal_multipliers_fn = "dispersal_multipliers.txt"#
BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resDEC$outputs@params_table["d","est"]#
estart = resDEC$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# Add j as a free parameter#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "Psychotria_DEC+J_M3areas_allowed_v1.Rdata"#
runslow = TRUE#
if (runslow)#
    {#
    #sourceall("/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resDECj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDECj = res#
    }#
#
########################################################
# PDF plots#
########################################################
pdffn = "Psychotria_DEC_vs_DEC+J_M3areas_allowed_v1.pdf"#
pdf(pdffn, width=6, height=6)#
#
########################################################
# Plot ancestral states - DEC#
########################################################
analysis_titletxt ="BioGeoBEARS DEC on Psychotria M3areas_allowed_unconstrained"#
#
# Setup#
results_object = resDEC#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
########################################################
# Plot ancestral states - DECJ#
########################################################
analysis_titletxt ="BioGeoBEARS DEC+J on Psychotria M3areas_allowed_unconstrained"#
#
# Setup#
results_object = resDECj#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res1 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()  # Turn off PDF#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr) # Plot it#
#
########################################################
########################################################
# DIVALIKE AND DIVALIKE+J ANALYSIS#
########################################################
########################################################
# NOTE: The BioGeoBEARS "DIVALIKE" model is not identical with #
# Ronquist (1997)'s parsimony DIVA. It is a likelihood#
# interpretation of DIVA, constructed by modelling DIVA's#
# processes the way DEC does, but only allowing the #
# processes DIVA allows (widespread vicariance: yes; subset#
# sympatry: no; see Ronquist & Sanmartin 2011, Figure 4).#
##
# DIVALIKE is a likelihood interpretation of parsimony#
# DIVA, and it is "like DIVA" -- similar to, but not#
# identical to, parsimony DIVA.#
##
# I thus now call the model "DIVALIKE", and you should also. ;-)#
########################################################
########################################################
#
########################################################
# Run DIVALIKE#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
BioGeoBEARS_run_object$dispersal_multipliers_fn = "dispersal_multipliers.txt"#
BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DIVALIKE model#
# Remove subset-sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "2-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "ysv*1/2"#
#
# Allow classic, widespread vicariance; all events equiprobable#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","init"] = 0.5#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","est"] = 0.5#
#
# No jump dispersal/founder-event speciation#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = 0.01#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = 0.01#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
runslow = TRUE#
resfn = "Psychotria_DIVALIKE_M3areas_allowed_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resDIVALIKE = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDIVALIKE = res#
    }#
#
########################################################
# Run DIVALIKE+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
BioGeoBEARS_run_object$dispersal_multipliers_fn = "dispersal_multipliers.txt"#
BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DIVALIKE+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resDIVALIKE$outputs@params_table["d","est"]#
estart = resDIVALIKE$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# Remove subset-sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "2-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "ysv*1/2"#
#
# Allow classic, widespread vicariance; all events equiprobable#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","init"] = 0.5#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","est"] = 0.5#
#
# Add jump dispersal/founder-event speciation#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
# Under DIVALIKE+J, the max of "j" should be 2, not 3 (as is default in DEC+J)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","min"] = 0.00001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","max"] = 1.99999#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "Psychotria_DIVALIKE+J_M3areas_allowed_v1.Rdata"#
runslow = TRUE#
if (runslow)#
    {#
    #sourceall("/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resDIVALIKEj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDIVALIKEj = res#
    }#
#
pdffn = "Psychotria_DIVALIKE_vs_DIVALIKE+J_M3areas_allowed_v1.pdf"#
pdf(pdffn, width=6, height=6)#
#
########################################################
# Plot ancestral states - DIVALIKE#
########################################################
analysis_titletxt ="BioGeoBEARS DIVALIKE on Psychotria M3areas_allowed_unconstrained"#
#
# Setup#
results_object = resDIVALIKE#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
########################################################
# Plot ancestral states - DIVALIKE+J#
########################################################
analysis_titletxt ="BioGeoBEARS DIVALIKE+J on Psychotria M3areas_allowed_unconstrained"#
#
# Setup#
results_object = resDIVALIKEj#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res1 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr)#
#
########################################################
########################################################
# BAYAREALIKE AND BAYAREALIKE+J ANALYSIS#
########################################################
########################################################
# NOTE: As with DIVA, the BioGeoBEARS BayArea-like model is #
# not identical with the full Bayesian model implemented #
# in the "BayArea" program of Landis et al. (2013). #
##
# Instead, this is a simplified likelihood interpretation#
# of the model.  Basically, in BayArea and BioGeoBEARS-BAYAREALIKE, #
# "d" and "e" work like they do in the DEC model of Lagrange #
# (and BioGeoBEARS), and then BayArea's cladogenesis assumption#
# (which is that nothing in particular happens at cladogenesis) is #
# replicated by BioGeoBEARS.#
##
# This leaves out 3 important things that are in BayArea:#
# 1. Distance dependence (you can add this with a distances #
#    matrix + the "x" parameter in BioGeoBEARS, however)#
# 2. A correction for disallowing "e" events that drive#
#    a species extinct (a null geographic range)#
# 3. The neat Bayesian sampling of histories, which allows#
#    analyses on large numbers of areas.#
##
# The main purpose of having a "BAYAREALIKE" model is #
# to test the importance of the cladogenesis model on #
# particular datasets. Does it help or hurt the data #
# likelihood if there is no special cladogenesis process?#
# #
# BAYAREALIKE is a likelihood interpretation of BayArea,#
# and it is "like BayArea" -- similar to, but not#
# identical to, Bayesian BayArea.#
# I thus now call the model "BAYAREALIKE", and you should also. ;-)#
########################################################
########################################################
#
########################################################
# Run BAYAREALIKE#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
BioGeoBEARS_run_object$dispersal_multipliers_fn = "dispersal_multipliers.txt"#
BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up BAYAREALIKE model#
# No subset sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
# No vicariance#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","est"] = 0.0#
#
# No jump dispersal/founder-event speciation#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = 0.01#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = 0.01#
#
# Adjust linkage between parameters#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "1-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/1"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "1-j"#
#
# Only sympatric/range-copying (y) events allowed, and with #
# exact copying (both descendants always the same size as the ancestor)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","init"] = 0.9999#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","est"] = 0.9999#
#
# Check the inputs#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
runslow = TRUE#
resfn = "Psychotria_BAYAREALIKE_M3areas_allowed_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resBAYAREALIKE = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resBAYAREALIKE = res#
    }#
#
########################################################
# Run BAYAREALIKE+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
BioGeoBEARS_run_object$dispersal_multipliers_fn = "dispersal_multipliers.txt"#
BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = TRUE#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up BAYAREALIKE+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resBAYAREALIKE$outputs@params_table["d","est"]#
estart = resBAYAREALIKE$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# No subset sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
# No vicariance#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","est"] = 0.0#
#
# *DO* allow jump dispersal/founder-event speciation (set the starting value close to 0)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
# Under BAYAREALIKE+J, the max of "j" should be 1, not 3 (as is default in DEC+J) or 2 (as in DIVALIKE+J)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","max"] = 0.99999#
#
# Adjust linkage between parameters#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "1-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/1"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "1-j"#
#
# Only sympatric/range-copying (y) events allowed, and with #
# exact copying (both descendants always the same size as the ancestor)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","init"] = 0.9999#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","est"] = 0.9999#
#
# NOTE (NJM, 2014-04): BAYAREALIKE+J seems to crash on some computers, usually Windows #
# machines. I can't replicate this on my Mac machines, but it is almost certainly#
# just some precision under-run issue, when optim/optimx tries some parameter value #
# just below zero.  The "min" and "max" options on each parameter are supposed to#
# prevent this, but apparently optim/optimx sometimes go slightly beyond #
# these limits.  Anyway, if you get a crash, try raising "min" and lowering "max" #
# slightly for each parameter:#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","min"] = 0.0000001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","max"] = 4.9999999#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","min"] = 0.0000001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","max"] = 4.9999999#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","min"] = 0.00001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","max"] = 0.99999#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "Psychotria_BAYAREALIKE+J_M3areas_allowed_v1.Rdata"#
runslow = TRUE#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resBAYAREALIKEj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resBAYAREALIKEj = res#
    }#
#
pdffn = "Psychotria_BAYAREALIKE_vs_BAYAREALIKE+J_M3areas_allowed_v1.pdf"#
pdf(pdffn, width=6, height=6)#
#
########################################################
# Plot ancestral states - BAYAREALIKE#
########################################################
analysis_titletxt ="BioGeoBEARS BAYAREALIKE on Psychotria M3areas_allowed_unconstrained"#
#
# Setup#
results_object = resBAYAREALIKE#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
########################################################
# Plot ancestral states - BAYAREALIKE+J#
########################################################
analysis_titletxt ="BioGeoBEARS BAYAREALIKE+J on Psychotria M3areas_allowed_unconstrained"#
#
# Setup#
results_object = resBAYAREALIKEj#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res1 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr)
dev.off()
dev.off()
# Set up empty tables to hold the statistical results#
restable = NULL#
teststable = NULL#
#
########################################################
# Statistics -- DEC vs. DEC+J#
########################################################
# We have to extract the log-likelihood differently, depending on the #
# version of optim/optimx#
LnL_2 = get_LnL_from_BioGeoBEARS_results_object(resDEC)#
LnL_1 = get_LnL_from_BioGeoBEARS_results_object(resDECj)#
#
numparams1 = 3#
numparams2 = 2#
stats = AICstats_2models(LnL_1, LnL_2, numparams1, numparams2)#
stats#
#
# DEC, null model for Likelihood Ratio Test (LRT)#
res2 = extract_params_from_BioGeoBEARS_results_object(results_object=resDEC, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
# DEC+J, alternative model for Likelihood Ratio Test (LRT)#
res1 = extract_params_from_BioGeoBEARS_results_object(results_object=resDECj, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
#
# The null hypothesis for a Likelihood Ratio Test (LRT) is that two models#
# confer the same likelihood on the data. See: Brian O'Meara's webpage:#
# http://www.brianomeara.info/tutorials/aic#
# ...for an intro to LRT, AIC, and AICc#
#
rbind(res2, res1)#
tmp_tests = conditional_format_table(stats)#
#
restable = rbind(restable, res2, res1)#
teststable = rbind(teststable, tmp_tests)#
#
########################################################
# Statistics -- DIVALIKE vs. DIVALIKE+J#
########################################################
# We have to extract the log-likelihood differently, depending on the #
# version of optim/optimx#
LnL_2 = get_LnL_from_BioGeoBEARS_results_object(resDIVALIKE)#
LnL_1 = get_LnL_from_BioGeoBEARS_results_object(resDIVALIKEj)#
#
numparams1 = 3#
numparams2 = 2#
stats = AICstats_2models(LnL_1, LnL_2, numparams1, numparams2)#
stats#
#
# DIVALIKE, null model for Likelihood Ratio Test (LRT)#
res2 = extract_params_from_BioGeoBEARS_results_object(results_object=resDIVALIKE, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
# DIVALIKE+J, alternative model for Likelihood Ratio Test (LRT)#
res1 = extract_params_from_BioGeoBEARS_results_object(results_object=resDIVALIKEj, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
#
rbind(res2, res1)#
conditional_format_table(stats)#
#
tmp_tests = conditional_format_table(stats)#
#
restable = rbind(restable, res2, res1)#
teststable = rbind(teststable, tmp_tests)#
#
########################################################
# Statistics -- BAYAREALIKE vs. BAYAREALIKE+J#
########################################################
# We have to extract the log-likelihood differently, depending on the #
# version of optim/optimx#
LnL_2 = get_LnL_from_BioGeoBEARS_results_object(resBAYAREALIKE)#
LnL_1 = get_LnL_from_BioGeoBEARS_results_object(resBAYAREALIKEj)#
#
numparams1 = 3#
numparams2 = 2#
stats = AICstats_2models(LnL_1, LnL_2, numparams1, numparams2)#
stats#
#
# BAYAREALIKE, null model for Likelihood Ratio Test (LRT)#
res2 = extract_params_from_BioGeoBEARS_results_object(results_object=resBAYAREALIKE, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
# BAYAREALIKE+J, alternative model for Likelihood Ratio Test (LRT)#
res1 = extract_params_from_BioGeoBEARS_results_object(results_object=resBAYAREALIKEj, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
#
rbind(res2, res1)#
conditional_format_table(stats)#
#
tmp_tests = conditional_format_table(stats)#
#
restable = rbind(restable, res2, res1)#
teststable = rbind(teststable, tmp_tests)#
#
##########################################################################
# ASSEMBLE RESULTS TABLES: DEC, DEC+J, DIVALIKE, DIVALIKE+J, BAYAREALIKE, BAYAREALIKE+J#
##########################################################################
teststable$alt = c("DEC+J", "DIVALIKE+J", "BAYAREALIKE+J")#
teststable$null = c("DEC", "DIVALIKE", "BAYAREALIKE")#
row.names(restable) = c("DEC", "DEC+J", "DIVALIKE", "DIVALIKE+J", "BAYAREALIKE", "BAYAREALIKE+J")#
restable = put_jcol_after_ecol(restable)#
restable#
#
# Look at the results!!#
restable#
teststable
# Loads to "restable"#
save(restable, file="restable_v1.Rdata")#
load(file="restable_v1.Rdata")#
#
# Loads to "teststable"#
save(teststable, file="teststable_v1.Rdata")#
load(file="teststable_v1.Rdata")#
#
# Also save to text files#
write.table(restable, file="restable.txt", quote=FALSE, sep="\t")#
write.table(unlist_df(teststable), file="teststable.txt", quote=FALSE, sep="\t")#
#
########################################################
# Model weights of all six models#
########################################################
restable2 = restable#
#
# With AICs:#
AICtable = calc_AIC_column(LnL_vals=restable$LnL, nparam_vals=restable$numparams)#
restable = cbind(restable, AICtable)#
restable_AIC_rellike = AkaikeWeights_on_summary_table(restable=restable, colname_to_use="AIC")#
restable_AIC_rellike = put_jcol_after_ecol(restable_AIC_rellike)#
restable_AIC_rellike#
#
# With AICcs -- factors in sample size#
# samplesize = length(tr$tip.label)#
# AICtable = calc_AICc_column(LnL_vals=restable$LnL, nparam_vals=restable$numparams, samplesize=samplesize)#
# restable2 = cbind(restable2, AICtable)#
# restable_AICc_rellike = AkaikeWeights_on_summary_table(restable=restable2, colname_to_use="AICc")#
# restable_AICc_rellike = put_jcol_after_ecol(restable_AICc_rellike)#
# restable_AICc_rellike#
#
# Also save to text files#
write.table(restable_AIC_rellike, file="restable_AIC_rellike.txt", quote=FALSE, sep="\t")#
#write.table(restable_AICc_rellike, file="restable_AICc_rellike.txt", quote=FALSE, sep="\t")#
#
# Save with nice conditional formatting#
write.table(conditional_format_table(restable_AIC_rellike), file="restable_AIC_rellike_formatted.txt", quote=FALSE, sep="\t")#
#write.table(conditional_format_table(restable_AICc_rellike), file="restable_AICc_rellike_formatted.txt", quote=FALSE, sep="\t")
library(MultinomialCI)#
#
############################################
# Pick your model name:#
############################################
model_name = "DEC"#
res = resDEC#
# model_name = "DEC"#
# res = resDEC#
#
########################################################
# Plot ancestral states - DEC#
########################################################
pdffn = paste0("Psychotria_", model_name, "_v1.pdf")#
pdf(pdffn, width=6, height=6)#
#
analysis_titletxt = paste0(model_name, " on Psychotria")#
#
# Setup#
results_object = res#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()  # Turn off PDF#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr) # Plot it#
#
########################################################
# Stochastic mapping on DEC M3b stratified with islands coming up#
########################################################
clado_events_tables = NULL#
ana_events_tables = NULL#
lnum = 0#
#
########################################################
# Get the inputs for Biogeographical Stochastic Mapping#
# Note: this can be slow for large state spaces and trees, since #
# the independent likelihoods for each branch are being pre-calculated#
# E.g., for 10 areas, this requires calculation of a 1024x1024 matrix#
# for each branch.  On a tree with ~800 tips and thus ~1600 branches, this was about 1.6 gigs#
# for storage of "BSM_inputs_file.Rdata".#
# Update: 2015-09-23 -- now, if you used multicore functionality for the ML analysis,#
# the same settings will be used for get_inputs_for_stochastic_mapping().#
########################################################
BSM_inputs_fn = "BSM_inputs_file.Rdata"#
BSMinputs_runslow = TRUE#
if (BSMinputs_runslow == TRUE)#
    {#
    stochastic_mapping_inputs_list = get_inputs_for_stochastic_mapping(res=res)#
    save(stochastic_mapping_inputs_list, file=BSM_inputs_fn)#
    } else {#
    # Loads to "stochastic_mapping_inputs_list"#
    load(BSM_inputs_fn)#
    } # END if (runInputsSlow)#
#
# Check inputs (doesn't work the same on unconstr)#
names(stochastic_mapping_inputs_list)#
stochastic_mapping_inputs_list$phy2#
stochastic_mapping_inputs_list$COO_weights_columnar#
stochastic_mapping_inputs_list$unconstr#
set.seed(seed=as.numeric(54321))#
#
BSM_runslow = TRUE#
if (BSM_runslow == TRUE)#
    {#
    # Saves to: RES_clado_events_tables.Rdata#
    # Saves to: RES_ana_events_tables.Rdata#
    BSM_output = runBSM(res, stochastic_mapping_inputs_list=stochastic_mapping_inputs_list, maxnum_maps_to_try=100, nummaps_goal=50, maxtries_per_branch=40000, save_after_every_try=TRUE, savedir=getwd(), seedval=12345, wait_before_save=0.01, master_nodenum_toPrint=0)#
#
    RES_clado_events_tables = BSM_output$RES_clado_events_tables#
    RES_ana_events_tables = BSM_output$RES_ana_events_tables#
    } else {#
    # Load previously saved...#
#
    # Loads to: RES_clado_events_tables#
    load(file="RES_clado_events_tables.Rdata")#
    # Loads to: RES_ana_events_tables#
    load(file="RES_ana_events_tables.Rdata")#
    BSM_output = NULL#
    BSM_output$RES_clado_events_tables = RES_clado_events_tables#
    BSM_output$RES_ana_events_tables = RES_ana_events_tables#
    } # END if (runBSMslow == TRUE)#
#
# Extract BSM output#
clado_events_tables = BSM_output$RES_clado_events_tables#
ana_events_tables = BSM_output$RES_ana_events_tables#
head(clado_events_tables[[1]])#
head(ana_events_tables[[1]])#
length(clado_events_tables)#
length(ana_events_tables)#
#
include_null_range = TRUE#
areanames = names(tipranges@df)#
areas = areanames#
max_range_size = 4#
#
# Note: If you did something to change the states_list from the default given the number of areas, you would#
# have to manually make that change here as well! (e.g., areas_allowed matrix, or manual reduction of the states_list)#
states_list_0based = rcpp_areas_list_to_states_list(areas=areas, maxareas=max_range_size, include_null_range=include_null_range)#
#
colors_list_for_states = get_colors_for_states_list_0based(areanames=areanames, states_list_0based=states_list_0based, max_range_size=max_range_size, plot_null_range=TRUE)#
#
# For BSMs, replace white with seashell white#
colors_list_for_states[colors_list_for_states == "#FFFFFF"] = "#FFF5EE"#
#############################################
# Setup for painting a single stochastic map#
#############################################
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
stratified = TRUE#
clado_events_table = clado_events_tables[[1]]#
ana_events_table = ana_events_tables[[1]]#
#
# cols_to_get = names(clado_events_table[,-ncol(clado_events_table)])#
# colnums = match(cols_to_get, names(ana_events_table))#
# ana_events_table_cols_to_add = ana_events_table[,colnums]#
# anagenetic_events_txt_below_node = rep("none", nrow(ana_events_table_cols_to_add))#
# ana_events_table_cols_to_add = cbind(ana_events_table_cols_to_add, anagenetic_events_txt_below_node)#
# rows_to_get_TF = ana_events_table_cols_to_add$node <= length(tr$tip.label)#
# master_table_cladogenetic_events = rbind(ana_events_table_cols_to_add[rows_to_get_TF,], clado_events_table)#
#
#############################################
# Open a PDF#
#############################################
pdffn = paste0(model_name, "_single_stochastic_map_n1.pdf")#
pdf(file=pdffn, width=6, height=6)#
#
# Convert the BSM into a modified res object#
master_table_cladogenetic_events = clado_events_tables[[1]]#
resmod = stochastic_map_states_into_res(res=res, master_table_cladogenetic_events=master_table_cladogenetic_events, stratified=stratified)#
#
plot_BioGeoBEARS_results(results_object=resmod, analysis_titletxt="Stochastic map", addl_params=list("j"), label.offset=0.5, plotwhat="text", cornercoords_loc=scriptdir, root.edge=TRUE, colors_list_for_states=colors_list_for_states, skiptree=FALSE, show.tip.label=TRUE)#
#
# Paint on the branch states#
paint_stochastic_map_branches(res=resmod, master_table_cladogenetic_events=master_table_cladogenetic_events, colors_list_for_states=colors_list_for_states, lwd=5, lty=par("lty"), root.edge=TRUE, stratified=stratified)#
#
plot_BioGeoBEARS_results(results_object=resmod, analysis_titletxt="Stochastic map", addl_params=list("j"), plotwhat="text", cornercoords_loc=scriptdir, root.edge=TRUE, colors_list_for_states=colors_list_for_states, skiptree=TRUE, show.tip.label=TRUE)#
#
#############################################
# Close PDF#
#############################################
dev.off()#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr)#
#
########################################################
# Plot all 50 stochastic maps to PDF#
########################################################
# Setup#
include_null_range = include_null_range#
areanames = areanames#
areas = areanames#
max_range_size = max_range_size#
states_list_0based = rcpp_areas_list_to_states_list(areas=areas, maxareas=max_range_size, include_null_range=include_null_range)#
colors_list_for_states = get_colors_for_states_list_0based(areanames=areanames, states_list_0based=states_list_0based, max_range_size=max_range_size, plot_null_range=TRUE)#
# For BSMs, replace white with seashell white#
colors_list_for_states[colors_list_for_states == "#FFFFFF"] = "#FFF5EE"#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
stratified = stratified#
#
# Loop through the maps and plot to PDF#
pdffn = paste0(model_name, "_", length(clado_events_tables), "BSMs_v1.pdf")#
pdf(file=pdffn, width=6, height=6)#
#
nummaps_goal = 50#
for (i in 1:nummaps_goal)#
    {#
    clado_events_table = clado_events_tables[[i]]#
    analysis_titletxt = paste0(model_name, " - Stochastic Map #", i, "/", nummaps_goal)#
    plot_BSM(results_object=res, clado_events_table=clado_events_table, stratified=stratified, analysis_titletxt=analysis_titletxt, addl_params=list("j"), label.offset=0.5, plotwhat="text", cornercoords_loc=scriptdir, root.edge=TRUE, colors_list_for_states=colors_list_for_states, show.tip.label=TRUE, include_null_range=include_null_range)#
    } # END for (i in 1:nummaps_goal)#
#
dev.off()#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr)
length(clado_events_tables)#
length(ana_events_tables)#
#
head(clado_events_tables[[1]][,-20])#
tail(clado_events_tables[[1]][,-20])#
#
head(ana_events_tables[[1]])#
tail(ana_events_tables[[1]])#
#
areanames = names(tipranges@df)#
actual_names = areanames#
actual_names#
#
# Get the dmat and times (if any)#
dmat_times = get_dmat_times_from_res(res=res, numstates=NULL)#
dmat_times#
#
# Extract BSM output#
clado_events_tables = BSM_output$RES_clado_events_tables#
ana_events_tables = BSM_output$RES_ana_events_tables#
#
# Simulate the source areas#
BSMs_w_sourceAreas = simulate_source_areas_ana_clado(res, clado_events_tables, ana_events_tables, areanames)#
clado_events_tables = BSMs_w_sourceAreas$clado_events_tables#
ana_events_tables = BSMs_w_sourceAreas$ana_events_tables#
#
# Count all anagenetic and cladogenetic events#
counts_list = count_ana_clado_events(clado_events_tables, ana_events_tables, areanames, actual_names)#
#
summary_counts_BSMs = counts_list$summary_counts_BSMs#
print(conditional_format_table(summary_counts_BSMs))#
#
# Histogram of event counts#
hist_event_counts(counts_list, pdffn=paste0(model_name, "_histograms_of_event_counts.pdf"))
########################################################
# Print counts to files#
########################################################
tmpnames = names(counts_list)#
cat("\n\nWriting tables* of counts to tab-delimited text files:\n(* = Tables have dimension=2 (rows and columns). Cubes (dimension 3) and lists (dimension 1) will not be printed to text files.) \n\n")#
for (i in 1:length(tmpnames))#
    {#
    cmdtxt = paste0("item = counts_list$", tmpnames[i])#
    eval(parse(text=cmdtxt))#
#
    # Skip cubes#
    if (length(dim(item)) != 2)#
        {#
        next()#
        }#
#
    outfn = paste0(tmpnames[i], ".txt")#
    if (length(item) == 0)#
        {#
        cat(outfn, " -- NOT written, *NO* events recorded of this type", sep="")#
        cat("\n")#
        } else {#
        cat(outfn)#
        cat("\n")#
        write.table(conditional_format_table(item), file=outfn, quote=FALSE, sep="\t", col.names=TRUE, row.names=TRUE)#
        } # END if (length(item) == 0)#
    } # END for (i in 1:length(tmpnames))#
cat("...done.\n")
library(MultinomialCI)    # For 95% CIs on BSM counts#
check_ML_vs_BSM(res, clado_events_tables, model_name, tr=NULL, plot_each_node=FALSE, linreg_plot=TRUE, MultinomialCI=TRUE)
library(phytools)#
Q = matrix(c(-3,1,1,1,1,-3,1,1,1,1,-3,1,1,1,1,-3),4,4)#
rownames(Q) = letters[1:4]#
colnames(Q) = letters[1:4]#
Q#
#
set.seed(seed=54321)#
simdata = sim.history(tree=tr, Q=Q, nsim=1)#
tipdata = simdata$states#
tipdata
simdata
set.seed(seed=54321)#
tr2 = make.simmap(tree=tr, x=tipdata, model="ER")#
tr2#
tr2$mapped.edge
set.seed(seed=54321)#
tr2 = make.simmap(tree=tr, x=sort(tipdata), model="ER")#
tr2#
tr2$mapped.edge
pdffn = "phytools_simmap.pdf"#
pdf(file=pdffn, width=6, height=6)#
#
plotSimmap(tr2,lwd=3)#
#
dev.off()#
cmdstr = paste0("open ", pdffn)#
system(cmdstr)
returned_mats = get_Qmat_COOmat_from_BioGeoBEARS_run_object(BioGeoBEARS_run_object=resDEC$inputs)#
ranges_list = returned_mats$ranges_list#
########################################################
# Convert a time-stratified BSM to a phytools BSM#
########################################################
#
res = resDEC#
clado_events_table = clado_events_tables[[1]]#
ana_events_table = ana_events_tables[[1]]
tr_wSimmap = BSM_to_phytools_SM(res=resDEC, clado_events_table=clado_events_tables[[6]], ana_events_table=ana_events_tables[[6]])
summary(tr_wSimmap)
print(tr_wSimmap)
countSimmap(tr_wSimmap)
tr_wSimmap$mapped.edge#
tr_wSimmap$maps
pdffn = "BSM_in_phytools_simmap_format.pdf"#
pdf(file=pdffn, width=6, height=6)#
#
cols = setNames(colors_list_for_states, ranges_list) #
plotSimmap(tr_wSimmap, lwd=3, colors=cols)#
#
dev.off()#
cmdstr = paste0("open ", pdffn)#
system(cmdstr)
########################################################
# Convert a list of time-stratified BSMs to a phytools list of BSMs#
########################################################
#
simmaps_list = BSMs_to_phytools_SMs(res=resDEC, clado_events_tables=clado_events_tables, ana_events_tables=ana_events_tables)#
#
summary(simmaps_list)#
print(simmaps_list)#
countSimmap(simmaps_list) # Gets big fast, for large states lists#
simmaps_list$maps#
#
# Plot to PDF#
pdffn = "50BSMs_in_phytools_simmap_format.pdf"#
pdf(file=pdffn, width=6, height=6)#
#
cols = setNames(colors_list_for_states, ranges_list) #
#
for (i in 1:length(simmaps_list))#
	{#
	plotSimmap(simmaps_list[[i]], colors=cols, lwd=3, hold=FALSE, add=FALSE, plot=TRUE)#
	}#
#
dev.off()#
cmdstr = paste0("open ", pdffn)#
system(cmdstr)
